int Analizador::funcionCallback(const void * inputBuffer, 
				void * outputBuffer, 
				unsigned long framesPerBuffer, 
				const PaStreamCallbackTimeInfo * timeInfo,
				PaStreamCallbackFlags statusFlags){

    if(!iniciado){
	cout << "### Analizador::Callback llamado por primera vez" << endl;
	iniciado = true;
    }
    const int **nInB = (const int **)(inputBuffer);
    //

    /*   
    // ######################
    // Paso transparente de input a output
    // Para pruebas.

    int **out = static_cast<int **>(outputBuffer);
    
    for (unsigned int i = 0; i < framesPerBuffer; ++i)
    {
    out[0][i] = nInB[0][i];
    out[1][i] = nInB[1][i];
    }
    
    //*/
	    

    for (unsigned int i = 0; i < framesPerBuffer; i++){
//    for(unsigned int i = 0; i < nFrames; i+=2){
//	cout << "posBuffer: " << miBuffer.pos << endl;

	// in[0][i] es el sonido en el canal izquierdo
	// in[1][i] es el sonido en el canal derecho

	miBuffer -> in[ miBuffer -> pos++] = nInB[0][i];
    }

    if( miBuffer -> pos > 4095){
	miBuffer -> pos = 0; 
	WindowFunc(3, 4096,  miBuffer -> in);
	PowerSpectrum(4096,  miBuffer -> in,  miBuffer -> out);
	float maxValue[] = {0,0,0};
	float maxPos[3];
		
	// Lo ponemos para que empiece a mirar frecuencias a partir de 450Hz
	// 

	/*
	  En el vector devuelto por la función de la FFT, cada posición i 
	  representa la amplitud de la componente con frecuencia i.
	  
	  Realmente i no es directamente la frecuencia. Para conocer la frecuencia 
	  real, hacemos una regla de tres: Si 2048 (el máximo del vector) es 22050 (la mayor frecuencia que se puede captar)
	  entonces i es x.

	  En nuestro caso, comenzamos el análisis en 450Hz, que es el límite
	  inferior que hemos seleccionado empíricamente.
	  22050 => 2048
	  450   => x
	  x = 450*2048/22050 = 41.79591 ~ 41

	*/
	  

	for(int i = 41; i < 2048; ++i){
	    for (int j = 0; j < 3; j++)
	    {
		if( miBuffer -> out[i] > maxValue[j]){
		    maxValue[j] =  miBuffer -> out[i];
		    maxPos[j] = i;
		    break;
		}
	    }			
	    
	    /*
	      Hemos seleccionado como límite superior 1500Hz
	      22050 => 2048
	      x     => i
	      x = i * 22050 / 2048 = i * 10.766
	    */

	    if(i * int_to_hz > 1500.) break;
	}

	miBuffer -> mayores[0] = maxPos[0]  * int_to_hz;
	miBuffer -> mayores[1] = maxPos[1]  * int_to_hz;
	miBuffer -> mayores[2] = maxPos[2]  * int_to_hz;

		
	std::cout << '\xd' << "Datos:" 
		  << std::setw(12) << miBuffer -> mayores[0] 
		  << std::setw(12) << miBuffer -> mayores[1]  
		  << std::setw(12) << miBuffer -> mayores[2]  
		  << std::setw(12) << maxValue[0]
		  << std::setw(12) << L.sonidoLimite()
		  << std::flush;	//



	//outputLog << maxPos << std::endl;
	miBuffer -> lastVolume = maxValue[0];
	miBuffer -> silencio = ((maxValue[0] < L.sonidoLimite() )?true:false);
    } //*/

    return paContinue;
}