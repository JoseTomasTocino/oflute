%%
%% Resumen de los aspectos más importantes
%% Copyright (C) 2008 Antonio García Domínguez
%% $Id: resumen.tex 629 2008-07-06 13:47:58Z antonio $
%%

Puede verse como, en este trabajo, ocupado más de la conversión de una
serie de formatos que de la usual manipulación de objetos del dominio
presente en las aplicaciones de gestión, y basado en otro Proyecto
anterior, el análisis ha tomado una porción relativamente pequeña de
la duración del proyecto.

A esto se le añade que los dos ``clientes'' eran expertos del dominio
de \ac{ACL2}, y que se tenía una comunicación constante con ellos,
como sugiere la metodología \ac{XP}. Para \ac{YAML} no hubo clientes,
pero esta carencia ha sido cubierta a través de su especificación
formal y el amplio número de herramientas que implementan y utilizan
este metalenguaje.

En cuanto al diseño, éste se ha modelado de manera incremental,
intentando evitar el diseño excesivo fuera de las necesidades
estrictas del proyecto. Todos los componentes han sufrido importantes
cambios en su diseño durante este proyecto: \postprocesador{} y
\yaxml{} han pasado a ser módulos Perl con la estructura estándar
recomendada por el \ac{CPAN}, y \visor{} se ha hecho completamente
genérico y multidocumento.

\section{Pruebas continuas}

Un factor fundamental para el éxito de este proyecto fue la
realización y planificación continua de pruebas durante toda su
duración.

Así, se realizaban pruebas de aceptación constantemente, junto con las
pruebas automáticas de regresión y de unidad. La principal ventaja de
automatizar las pruebas es que aseguran una cierta funcionalidad
continuamente sin afectar a la velocidad del desarrollo del proyecto.

Durante el desarrollo del proyecto, se presentaron algunos casos en
los que las propias pruebas de unidad no habían capturado algunos
fallos. Tras el refinamiento de las pruebas para detectar el fallo y
la corrección de este, no solamente se consiguió arreglar el fallo,
sino también garantizar que no volvería a aparecer en el proyecto.

\section{Diseño iterativo y dirigido por pruebas}

% Pruebas de unidad
% Herramientas de refactorización (Eclipse)

A menudo, intentar establecer un diseño sin comprender o conocer
totalmente los requisitos resulta en software que es innecesariamente
más complejo de lo que podría ser. Mayor complejidad implica mayor
propensión a fallos y mayor dificultad en su mantenimiento y posterior
expansión. Los argumentos usados para defender este diseño temprano es
que el coste de realizar cambios en el diseño crece rápidamente a
medida que se avanza en el desarrollo.

Esta es otra de las razones por las que existe tanto interés en las
pruebas continuas automatizadas en el desarrollo de software. estas
pruebas ayudan a reducir una de las fuentes principales del coste de
estos cambios en el diseño: la introducción de nuevos defectos. Cada
vez que se realiza un cambio, se ejecutan de nuevo todas las pruebas,
y el cambio sólo se envía al repositorio central si son superadas. De
esta forma, podemos asegurar que toda la funcionalidad garantizada en
la anterior versión sigue funcionando actualmente.

No es sólo cuestión de evitar defectos y mantener al diseño flexible:
se ha comprobado que los diseños resultantes de escribir primero las
pruebas y luego implementar la funcionalidad son de mucha mayor
calidad. En muchos casos, el código es difícil de probar no tanto por
la complejidad de la lógica que entraña, sino porque no se pensó en
las pruebas desde un comienzo, y por lo tanto no es lo bastante
flexible y cohesivo. 

Otra importante fuente de costes a la hora de revisar un diseño es la
realización de los cambios necesarios sobre el propio código, sobre
todo cuando el elemento a cambiar es referenciado por muchos
otros. Estos costes se pueden reducir en gran medida si disponemos de
editores con funcionalidades de refactorización y detección de
referencias entre elementos del programa: así ha sido el caso con
Java, para el que se utiliza el \ac{IDE} Eclipse como editor. A
diferencia de otros \ac{IDE}, Eclipse no nos ata a él: el fichero que
dirige toda la compilación es un fichero Ant normal y corriente, que
puede ser usado fuera de Eclipse sin problemas. Se echa en falta una
herramienta parecida para módulos Perl, que sin duda se halla motivada
por la mayor dificultad que su desarrollo entraña.

\section{Transformaciones declarativas dirigidas por datos}

Uno de los objetivos en el desarrollo de \visor{} para este Proyecto
fue su completa separación de \ac{ACL2}. El hecho de definir las
transformaciones no a través de código Java, sino como ficheros
externos fácilmente instalables en \visor{} fue un punto clave:
extraer la lógica de \ac{ACL2} de \visor{} y moverla a
\postprocesador{} fue sólo cuestión de retirar el antiguo diálogo de
importación y reemplazarlo por el nuevo sistema de descriptores de
formatos.

Al mismo tiempo, estos ficheros externos utilizan un lenguaje
especialmente indicado para realizar transformaciones sobre los
documentos \ac{XML}, \ac{XSLT}. Esto hace que sean mucho más fáciles
de definir que si, por ejemplo, usáramos el \ac{API} \ac{DOM}.

\section{Mejora como producto software}

Un aspecto que se identificó al final del anterior Proyecto sobre el
que se basa el actual fue la necesidad de facilitar otros aspectos no
directamente relacionados con su funcionalidad: la instalación era
completamente manual, y la documentación se hallaba en un único
formato.

Durante el desarrollo de este Proyecto, se han mejorado notablemente
los aspectos de instalación, con distribuciones para los módulos Perl
que sólo requieren ser descomprimidas para los usuarios e instalación
y comprobación automática de dependencias para los desarrolladores.
Además, se han elaborado las primeras versiones de los paquetes Debian
de los tres componentes, y se han recogido las experiencias obtenidas
en una guía de elaboración de paquetes Debian públicamente disponible
a través de Internet, e incluida en la presente memoria.

En adelante, toda la documentación se hará en el wiki público
(\url{http://wiki.shoyusauce.org/}), que además dispone de la
posibilidad de mantener múltiples traducciones de cada
artículo. Actualmente toda la documentación del wiki se halla
disponible en inglés.



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../memoria"
%%% End: 
