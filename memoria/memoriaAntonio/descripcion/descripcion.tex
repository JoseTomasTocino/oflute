
\section{Perspectiva del producto}
\label{sec:desc}

\subsection{Entorno de los productos}
\label{sec:desc_prod}

El proyecto está formado por \visor{}, \postprocesador{} y
\yaxml{}. Los dos primeros se basan sobre las versiones finales del
visor y el post-procesador presentados en el Proyecto Fin de Carrera
``Post-procesador y Visor de Demostraciones del Sistema ACL2'', y el
tercero se halla escrito desde cero. Los tres productos tienen entidad
propia, pudiendo usarse integrados a través de una sencilla interfaz o
por separado.

\visor{}, \yaxml{} y \postprocesador{} se hallan en continuo
desarrollo, y se seguirán mejorando más allá de este Proyecto. En el
caso de \yaxml{} no se añadirá nueva funcionalidad, sino que se
seguirá depurando su corrección ante ejemplos más complejos y nuevas
versiones de la especificación de \ac{YAML}.

\postprocesador{} sólo trata un subconjunto, aunque ampliado respecto
a su versión original, de las demostraciones del sistema \ac{ACL2}.

\subsection{Interfaces software y hardware}
\label{sec:desc_sw_hw}

La interfaz entre \postprocesador{} y cualquier sistema que haga uso
de su salida (por ejemplo \visor{}) está bien definida a través de su
\ac{POD}, que indica la forma de invocación correcta, y de su
\ac{DTD}, que permite conocer el formato de la salida sin tener que
examinar el programa.

No existe una \ac{DTD} explícita para \yaxml{}, puesto que el formato
de la entrada resultante depende en gran medida del documento
proporcionado: no olvidemos que \ac{YAML}, el formato convertido, es
un metalenguaje, al igual que \ac{XML}, el formato destino.

Se ha de procurar también reducir el acoplamiento de los conversores y
\visor{} con el sistema operativo y hardware al mínimo, para
garantizar transportabilidad a lo largo de distintas arquitecturas y
sistemas operativos.

\subsection{Interfaz de usuario}
\label{sec:desc_ui}

En cuanto a la interfaz de usuario, se ha procurado hacerla lo más
sencilla y flexible posible, con una simple vista que permita
relacionar la estructura en forma de árbol de la demostración con
información acerca del elemento actualmente seleccionado.

La integración con el resto del entorno del usuario y la adaptabilidad
a sus necesidades mediante la configuración de su comportamiento
permitirán al usuario sacarle el mayor provecho posible a esta
aplicación.

Todas las funciones deben estar disponibles por teclado y ratón, por
razones de accesibilidad y usabilidad.

\section{Funciones} 
\label{sec:desc_func}

\subsection{\nombrevisor{}}

\begin{itemize}
\item Navegación jerárquica simultánea por múltiples documentos a
  distintos niveles de detalle, con vínculos entre sus elementos y con
  elementos de otros documentos.

\item Búsqueda a lo largo del documento, con diversas opciones de
  filtrado.

\item Integración con nuevos formatos especificados por el usuario,
  sin necesidad de modificar el código. Cada formato puede especificar
  el editor y (opcionalmente) el conversor a \ac{XML} con el que
  deberá integrarse \visor{}.

  Los formatos son localizables a distintos idiomas, y personalizables
  por cada usuario del sistema. Se deben de poder restaurar los
  ajustes originales del formato en cualquier momento.

\item Cambio en tiempo de ejecución del comportamiento de visualización
  del documento y sus nodos, que debe ser extensible por el usuario
  sin necesidad de añadir código específico a \visor{}.

\item Monitorización en segundo plano del documento abierto,
  volviéndolo a abrir cuando se produzcan cambios en él. Esto
  posibilita su edición y visualización en paralelo.
\end{itemize}

\subsection{\nombrepostprocesador{}}

\begin{itemize}
\item Conversión automática de un subconjunto de interés didáctico de
  la salida de \ac{ACL2} a \ac{XML}, incluyendo demostraciones
  divididas entre múltiples ficheros.

\item Generación de grafos de dependencias de una demostración con
  todos los libros usados, a cualquier número de niveles de
  profundidad.

\item Invocación automática de \ac{ACL2} que tenga en cuenta las
  dependencias entre los distintos ficheros implicados y repita las
  demostraciones sólo ante cambios en las fuentes originales.

\item Facilidad de mantenimiento y de actualización ante cambios en la
  salida entre versiones distintas de \ac{ACL2}.

\item Diversas hojas de estilo que produzcan información agregada a
  múltiples niveles en formato de hipertexto, manteniendo las
  dependencias directas e inversas entre todos los elementos,
  incluyendo a aquellos que pertenezcan a otros documentos.
\end{itemize}

\subsection{\nombreyaxml{}}

\begin{itemize}
\item Conversión automática sin pérdidas ni cambios en la información
  de \ac{YAML} a \ac{XML}.

\item Transformación de anclas y alias \ac{YAML} a enlaces basados en
  identificadores únicos y atributos específicos.

\item Hojas de estilo para \visor{} que tengan en cuenta los aspectos
  específicos de la salida producida por la conversión anterior.
\end{itemize}


\section{Características del usuario}
\label{sec:desc_usuarios}

Podríamos establecer varios tipos de uso para este proyecto:

\begin{description}
\item[\visor{} integrado con \yaxml{}] 

  Esta combinación permitirá a \visor{} abrir cualquier documento
  escrito en un lenguaje basado en el metalenguaje \ac{YAML}. Esto
  incluye marcadores de Firefox 3, volcados de bases de datos del
  entorno de desarrollo web Django, o descriptores de módulos Perl,
  por ejemplo.

  Tiene por lo tanto un amplio abanico de posibilidades dirigido a un
  gran número de usuarios, que se dividirán entre los \emph{usuarios
    finales} que emplearán las hojas ya existentes, y que no
  requerirán más conocimientos que los necesarios para instalar la
  aplicación y \yaxml{}, y los \emph{usuarios avanzados}, que podrán
  personalizar sus visualizaciones a su antojo.

  Esta funcionalidad cobrará mayor utilidad cuando se le añada a
  \visor{} la capacidad de publicar la visualización en efecto como
  una página \acs{WWW}. Se podría entonces mostrar en una web de forma
  muy sencilla nuestros marcadores de Firefox, por ejemplo, y con más
  información que la exportación por defecto a \ac{HTML} provee.

\item[\visor{} integrado con \postprocesador{}] 
  
  El usuario sólo emplea el post-procesador mediante su integración
  con el visor para navegar por demostraciones de \ac{ACL2}. Dentro de
  este modelo de uso, distinguimos dos tipos de usuarios:

  \begin{description}
  \item[Estudiante] 

    Un estudiante de ciclo superior estudiando métodos formales de
    desarrollo de software usaría esta herramienta para ayudarle a
    visualizar el proceso de demostración de \ac{ACL2} sobre
    demostraciones sencillas.

    Existen otras herramientas para \ac{ACL2} realizadas por motivos
    pedagógicos para este tipo de usuarios, pero se centran en
    aspectos distintos.

    Un ejemplo es \texttt{DrACuLa}, basado en el entorno de Scheme (un
    dialecto de Lisp) llamado \texttt{DrScheme}.  Entre algunos de los
    lenguajes disponibles, se puede hallar un dialecto simplificado de
    \ac{ACL2} extendido con unas librerías de manipulación de gráficos
    llamadas ``teachpacks'' para agilizar la enseñanza, ilustrando el
    hecho de que los métodos formales se pueden aplicar a proyectos
    software normales, y no sólo a aquellos con un alto contenido
    teórico.

  \item[Investigador] 
    \index{dependencia inversa}

    Un investigador especializado en \ac{ACL2} preferiría utilizar una
    herramienta que estructurara de alguna forma la demostración en
    texto plano obtenida.

    Podría además aprovechar la información adicional como las
    dependencias inversas y otros enlaces y estadísticas para
    realizar su trabajo de forma más eficiente.

    Cuando se añadiera la posibilidad de publicar una demostración
    como una página \acs{WWW}, podría añadir a su página personal
    enlaces a algunas de sus demostraciones.

  \end{description}

  Ambos tipos de usuario tienen un alto nivel de experiencia en el uso
  de ordenadores, por lo cual se espera que no tengan problemas a la
  hora de configurar su entorno, si bien no se asumen conocimientos
  específicos de las herramientas usadas.
  
  Notemos que, en la actualidad, \postprocesador{} sólo trata un
  subconjunto limitado de la entrada, y así hemos de limitarnos al uso
  puramente didáctico, es decir, al usuario estudiante.

  Sin embargo, la intención de este proyecto es extender su soporte
  hasta el punto que sea útil también para un investigador. El
  tratamiento de demostraciones divididas a lo largo de varios
  ficheros implementado en este Proyecto es un primer paso en esa
  dirección.

\item[Sólo \visor{}] 

  \visor{} no contiene lógica específica para ningún formato en su
  código Java para la visualización. Toda se halla en las hojas
  \ac{XSLT} y los descriptores de formatos de documentos.

  Añadiendo nuevas hojas, el usuario podría realizar sus propias
  visualizaciones de cualquier documento \ac{XML}, pudiendo establecer
  enlaces entre los nodos o cambiar el icono o etiqueta mostrado en el
  árbol del documento, entre otras cosas.

  Si el formato a tratar ya se basa en \ac{XML}, elaborar un
  descriptor de formato de documento es completamente opcional: sólo
  haría falta si quisiéramos utilizar una extensión o un editor
  distintos a los usados para \ac{XML} en general.

\item[Sólo \postprocesador{}] 

  El usuario no utiliza \visor{}, y se limita a procesar de alguna
  forma la salida de \postprocesador{}. Este tipo de usuario sería,
  realmente, un desarrollador que tendría cierta experiencia con
  \ac{ACL2} y deseara darle otra aplicación a la salida. Los autores
  de Mizar tenían algo similar en mente cuando cambiaron el formato de
  su salida a \ac{XML}~\cite{Urban05}.

  Un ejemplo podría ser usar una hoja \ac{XSLT} para generar una
  versión \ac{HTML} de la demostración, que se pudiera publicar en un
  servidor \acs{WWW}, por ejemplo. 

  También se podría generar un documento \ac{XSL-FO} y, usando un
  procesador \ac{XSL-FO}, obtener una salida en formato \ac{PDF} o
  PostScript, entre otros.

\item[Sólo \yaxml{}] 

  Aunque están empezando a surgir validadores para \ac{YAML}, como
  Kwalify (disponible en~\url{http://www.kuwata-lab.com/kwalify/}), y
  en principio se podría en transformar un documento \ac{YAML} a
  partir de un algoritmo \emph{ad hoc} sobre los datos deserializados,
  hay muchas menos herramientas que para \ac{XML}.

  Combinando \yaxml{} y la versión refinada de \ac{YAXML} que incluye,
  un desarrollador podría convertir el documento \ac{YAML} a \ac{XML},
  aplicarle la herramienta \ac{XML} en cuestión, y luego devolver el
  resultado \ac{XML} a \ac{YAML}.

  La batería de pruebas de \yaxml{} se ocupará de asegurar que en todo
  el ciclo \ac{YAML} $\rightarrow$ \ac{XML} $\rightarrow$ \ac{YAML} no
  se produzcan pérdidas ni cambios indeseados en la información del
  documento original.

\end{description}

\section{Restricciones generales}
\label{sec:desc_restr}

\subsection{Control de versiones}
\label{sec:desc_svn}

Al seguir un proceso incremental de desarrollo de software, se
necesitó un sistema de control de versiones de todas las fuentes del
proyecto.

Estos sistemas permiten almacenar todas las versiones de un árbol de
ficheros, pudiendo así manipular todas las revisiones de cualquier
fichero en cualquier momento.

Además de servir como una medida de seguridad contra la pérdida de
información accidental, agilizan los cambios drásticos, ya que no hay
que establecer medidas especiales por si fallaran: se pueden revertir
los cambios hechos en cualquier momento.

En particular, \texttt{Subversion} es un sistema que trata de resolver
las insuficiencias del conocido \ac{CVS}, pudiendo mantener revisiones
de directorios completos, establecer propiedades especiales sobre los
elementos del repositorio y enviar nuevas revisiones de forma atómica,
entre otras cosas.

Dispone de excelente documentación, con un libro~\cite{svnhandbook}
disponible bajo la licencia Creative Commons.

\subsection{Lenguajes de programación}
\label{sec:desc_lang}

Con vistas a la transportabilidad, se eligieron dos lenguajes de
programación con implementaciones interpretadas para el proyecto: Perl
y Java.

Ambos lenguajes reducen significativamente el potencial de error
gracias a su uso de recolectores de basura: Perl utiliza un recolector
basado en recuento de referencias y la \ac{JVM} de Sun usa un
algoritmo de barrido y marcado más avanzado.

\begin{description}
\item[\ac{Perl}] 
  \index{Perl}

  Este lenguaje es un candidato ideal para la labor de
  \postprocesador{}, teniendo la implementación con mayor
  funcionalidad de expresiones regulares integrada dentro del propio
  lenguaje. En el caso de \yaxml{}, cualquier otro lenguaje con un
  sistema de tipos dinámico (como Ruby o Python) habría servido, pero
  por familiaridad con el entorno y por simplificar la instalación de
  ambos convertidores, se optó por el mismo lenguaje.

  El rendimiento de Perl para el procesado automático avanzado de
  textos es alto, y se trata de una herramienta muy estable: la
  primera revisión de la versión de uso generalizado actual, la 5.8,
  se remota al 2002. La versión estable más reciente actualmente, la
  5.10, fue publicada en diciembre de 2007.

  Es interpretado en el sentido que el código fuente de un guión Perl
  es compilado a instrucciones a ser interpretadas por una máquina
  virtual antes de cada ejecución.

  Otra ventaja es la disponibilidad en forma de módulos de todo tipo
  de extensiones a las capacidades básicas de Perl en el \ac{CPAN}.

\item[\Index{Java}] 
  
  Otro requisito era poder crear una interfaz gráfica de cierta
  complejidad con la mayor transportabilidad posible.

  A pesar de la existencia de otros marcos de desarrollo de \acs{GUI}
  basados en lenguajes con implementaciones interpretadas como
  PerlGTK, PyGTK o wxPython, se deseaba además tener una plataforma
  integrada con soporte para \ac{XSLT} sin necesidad de dependencias
  externas, y la capacidad de mantener un aspecto atractivo y uniforme
  entre plataformas.

  Además, el \acs{API} usado (Swing) es mucho más maduro y estable que
  el de cualquiera de las tres alternativas anteriores. Otra opción
  habría sido usar el \ac{SWT}, alternativa de \acs{IBM} que utiliza
  componentes nativos, pero su soporte de sistemas operativos
  distintos a Windows es inferior al de Swing.

  El problema de la velocidad no es tan grave como se podría esperar,
  pues desde la versión 1.3 del \ac{JRE} la \ac{JVM} o máquina virtual
  de Java incluye un compilador en tiempo de ejecución o \ac{JIT}
  llamado HotSpot, que convierte a código nativo y optimiza
  agresivamente las partes más usadas del programa de forma dinámica.

\end{description}

\subsection{Sistemas operativos y hardware}
\label{sec:desc_os}

Aunque tanto \ac{Perl} como Java están disponibles para una gran cantidad
de plataformas, para simplificar, este proyecto ha sido desarrollado y
probado únicamente en Windows XP (con el Service Pack 2) y en
\acs{GNU}/Linux, ejecutando la versión 8.04 (Hardy Heron \acl{LTS}) de
la distribución Ubuntu, basada en Debian, y la versión 10.3 de la
distribución openSUSE.

\visor{} puede funcionar sobre cualquier entorno Java que implemente
la \ac{J2SE} 5.0 como mínimo. Esto incluye evidentemente a los
\ac{JRE} 5.0 y 6.0 de Sun y recientemente a las versiones 6.0 y 7.0 de
OpenJDK~\cite{OpenJDK}. OpenJDK es una iniciativa liderada por Sun
que, en combinación con los esfuerzos del proyecto
IcedTea~\cite{IcedTea}, ha conseguido una versión prácticamente 100\%
funcional y basada en software libre de las \ac{J2SE} 6.0 y la futura
7.0.

Como mínimo, existen ediciones de la \ac{J2SE} 5.0 o superiores para
Solaris, MacOS X 10.4, Windows 32-bits y 64-bits y Linux 32-bits y
64-bits. El soporte de 64-bits depende de la \acs{CPU} usada: no se
pueden usar procesadores Intel Itanium, pero sí todos los demás chips
de 64 bits de \ac{AMD} e Intel.

Por el lado de \ac{Perl}, la transportabilidad es mucho mejor:

\begin{itemize}
\item Apple Mac OS Classic 8.1 en adelante.
\item Windows 95/98/ME/NT/2000/XP.
\item Cualquier sistema basado en UNIX (los *BSD, Linux, Solaris y Mac
  OS X, entre otros).
\item Otros sistemas menos comunes, como: TiVo, HP-UX, No\-vell
  Net\-wa\-re, NonStop, Plan 9, VMS, etc.
\end{itemize}

\subsection{Bibliotecas y módulos usados}
\label{sec:desc_bibliotecas}

\subsubsection{Perl}
\label{sec:desc_restr_perl}

Se ha usado la versión 5.8.8 para el desarrollo de este proyecto. La
primera revisión de la versión 5.8 de Perl, la 5.8.0, introdujo
diversas mejoras, pero sólo nos afecta realmente la introducción en la
distribución estándar del módulo \Index{Locale::Maketext}, usado para
localización de los mensajes de error.

Es posible por lo tanto que los convertidores funcionen instalando
manualmente dicho módulo y demás dependencias con las versiones 5.6.x,
que implementan la imprescindible sintaxis orientada a objetos. No ha
habido tiempo para hacer pruebas al respecto, sin embargo.

Ha sido necesario el uso de varios módulos: algunos vienen incluidos
en la distribución estándar de Perl, y otros se han de instalar por
separado. Estos últimos se instalan automáticamente durante la
compilación de los convertidores siempre que las bibliotecas
requeridas estén presentes en el sistema. Se tratan de:

\begin{description}

\item[File::ShareDir] 
  \index{módulo Perl!File::ShareDir}

  Permite calcular las rutas a ficheros instalados a través del
  mecanismo de directorios automáticos de Perl en localizaciones
  accesibles por todos los usuarios del sistema y acceder a ellos. De
  la instalación se ocupa \modulo{Module::Install}.

\item[File::Spec] 
  \index{módulo Perl!File::Spec}

  Realiza transformaciones sobre rutas a ficheros de manera
  transportable, como convertir rutas relativas a absolutas, por
  ejemplo.

\item[Getopt::Long] 
  \index{módulo Perl!Getopt::Long}

  Mediante este módulo, se pueden recibir opciones de la línea de
  órdenes en formato \acs{POSIX} con las extensiones \acs{GNU}, como
  la posibilidad de introducir argumentos entre las opciones. Se
  pueden también usar opciones en formato abreviado y reunirlas, para
  usuarios expertos.

\item[Module::Install] 
  \index{módulo Perl!Module::Install}

  Permite escribir fácilmente instaladores de módulos Perl que sigan
  las mejores prácticas del \ac{CPAN}, e instalen de forma automática
  todas las dependencias, de manera recursiva. Los instaladores
  resultantes son compatibles con cualquier herramienta que funcione
  con instaladores generados mediante el módulo estándar \emph{de
    facto} \modulo{ExtUtils::MakeMaker} o con \modulo{Module::Build}.

  Incorpora funcionalidades para verificar dependencias de ejecución y
  compilación, crear distribuciones del código, lanzar las pruebas de
  unidad, e instalar ejecutables y ficheros para su posterior uso con
  \modulo{File::ShareDir}, entre otras.

\item[PAR] 
  \index{módulo Perl!PAR}

  Permite crear ficheros \fichero{.par} de módulos y/o guiones Perl
  que funcionan de forma muy similar a los \fichero{.jar} en Java: son
  archivos comprimidos que reúnen todo el código necesario, y pueden
  ejecutarse de forma muy sencilla utilizando la herramienta de línea
  de órdenes \verb#parl#.

\item[PAR::Packer] 
  \index{módulo Perl!PAR::Packer}

  Este módulo permite crear ejecutables monolíticos específicos a la
  arquitectura y sistema operativo actual de cualquier guión
  Perl. Incorpora una herramienta de línea de órdenes llamada
  \verb#pp# que reúne en el mismo ejecutable los módulos, bibliotecas
  y demás ficheros usados, e incluso el propio intérprete de Perl.

  A diferencia de \modulo{PAR}, los ficheros generados son
  completamente autosuficientes, y no requieren por lo tanto de ningún
  proceso de instalación previo.

\item[Pod::Usage] 
  \index{módulo Perl!Pod::Usage}

  Permite documentar fácilmente el uso correcto del programa, pudiendo
  usar la sección \ac{POD} incrustada en el guión principal para
  generar ayuda en línea en formato \verb|man| o texto puro.

\item[Test::More] 
  \index{módulo Perl!Test::More}

  Marco de pruebas de unidad basado completamente en Perl que
  reemplaza y extiende al módulo \modulo{Test::Simple}.

\item[Test::Pod::Coverage] 
  \index{módulo Perl!Test::Pod::Coverage}

  Módulo ocupado de implementar pruebas de unidad sobre la cobertura
  de la documentación incluida en el propio código Perl en formato
  \ac{POD}. Se asegura de que todo método público definido por todos
  los módulos tenga documentación asociada.

\item[XML::LibXML] 
  \index{módulo Perl!XML::LibXML}

  Es uno de los módulos que puede emplear \modulo{XML::Validate} para
  implementar su funcionalidad. Provee de una interfaz Perl a la
  biblioteca C \ac{XML} del proyecto GNOME, \verb#libxml2#
  (véase~\url{http://xmlsoft.org/}), que evidentemente ha de estar ya
  instalada.

\item[XML::SemanticDiff] 
  \index{módulo Perl!XML::SemanticDiff}

  Permite comprobar las diferencias entre dos documentos \ac{XML},
  notificándolas a través de una serie de manejadores de
  eventos. Estos manejadores de eventos pueden añadir lógica
  específica con información acerca de qué diferencias resultan de
  interés y qué otras diferencias no son tan importantes, y también
  pueden etiquetar dichos sucesos con información adicional.

\item[XML::Validate] 
  \index{XML::Validate}

  Da la posibilidad de validar documentos \ac{XML} fácilmente usando
  diversas bibliotecas externas. Esto permite usar ficheros \ac{DTD},
  por ejemplo. Actualmente sólo se usa en las pruebas de unidad, pero
  en un futuro se podría emplear para la validación de todos los
  resultados producidos por \postprocesador{}.

\item[XML::Writer] 
  \index{módulo Perl!XML::Writer}

  Para salida con verificación básica de \ac{XML}, usando un interfaz
  sencillo.

\end{description}

\subsubsection{Java}
\label{sec:desc_restr_java}

\index{Look \& Feel} 

Por otro lado, la amplitud de la \ac{J2SE} 5.0 ha permitido
implementar \visor{} limitando las dependencias externas a un
\textit{Look \& Feel} libre distribuido bajo licencia \ac{BSD} llamado
JGoodies Looks, disponible en \url{https://looks.dev.java.net/}.

La implementación de \ac{JAXP} 1.3 de \ac{J2SE} 5.0 usa dos
bibliotecas de Apache:

\begin{description}
\item[XSLTC 2.6.0] 
  \index{Apache!XSLTC}
  \index{XSLTC|see{Apache!XSLTC}}
  \index{Apache!Xalan}
  \index{Xalan|see{Apache!Xalan}}

  Implementa los estándares del \ac{W3C} \ac{XSLT} 1.0 y XPath 1.0.
  Basado en Apache Xalan, con una serie de parches de Sun.

  Esta nueva versión reemplaza al antiguo motor \ac{XSLT} Xalan
  interpretado. En este nuevo motor, toda hoja \ac{XSLT} es compilada
  de antemano a instrucciones de la \ac{JVM}, generando un
  \emph{\Index{translet}}, cuya ejecución es notablemente más rápida.

  La limitación de XSLTC consiste en que no permite elementos de
  extensión, parte del estándar \ac{XSLT} 1.0.  Tampoco puede usar
  fuentes \ac{JDBC} en la transformación, ni programas incrustados
  escritos en otros lenguajes (Java, por ejemplo).

\item[\Index{Xerces} 2.6.2] 
  \index{Xerces|see{Apache!Xerces}}
  \index{Apache!Xerces}
  \index{Crimson|see{Apache!Crimson}}
  \index{Apache!Crimson}

  Proporciona analizadores \ac{W3C} \ac{DOM} nivel 3 y \ac{SAX}
  2.0.2, junto con implementaciones de otras partes del \ac{JAXP} 1.3.
  De forma análoga a XSLTC, se halla basado en la versión oficial de
  Apache Xerces, junto con una serie de parches seleccionados.

  Esta biblioteca reemplaza a Crimson, otro analizador \ac{XML} de
  Apache, incluido en \ac{J2SE} 4.0 como parte del \ac{JAXP} 1.1. Este
  analizador estaba centrado más en la simplicidad y bajo consumo de
  memoria, y se halla listado actualmente como ``proyecto en
  hibernación'' en \url{http://xml.apache.org}, la web de proyectos
  \ac{XML} de Apache.

\end{description}

Para desarrollar \visor{}, se han usado las siguientes herramientas:

\begin{description}
\item[Ant 1.7.0] 
  \index{Ant|see{Apache!Ant}}
  \index{Apache!Ant}

  Sistema de gestión de tareas de compilación, empaquetado, generación
  de documentación y lanzamiento de pruebas de unidad, entre otras. Es
  similar al conocido \acs{GNU} Make, siendo la principal diferencia
  su soporte multiplataforma, gracias a estar implementado en Java.

\item[Eclipse 3.3.2] 
  \index{Eclipse}

  \ac{IDE} desarrollado en sus inicios por \acs{IBM} que es, junto con
  NetBeans, uno de los más usados hoy en día. Aunque es
  particularmente popular en la comunidad Java, existen versiones para
  otros lenguajes, como C o \CPP. Dispone de herramientas para hacer
  rápidamente refactorizaciones en el código, facilitando enormemente
  cualquier cambio al diseño de una aplicación.

\item[\Index{JUnit} 3.8.2] 
  \index{JUnit}
  \index{pruebas!de unidad}

  Popular marco de desarrollo de pruebas de unidad, inspirado en el
  marco SUnit para Smalltalk, que ha originado otros marcos parecidos,
  como CppUnit para \CPP. Se ha usado la versión 3.8 y no las versiones
  4.x dado que estas últimas no están aún soportadas por Ant, tras
  cambios en su \ac{API}.

\end{description}

\section{Requisitos para futuras versiones}
\label{sec:desc_futuro}

\subsection{\nombrevisor{}}

\begin{itemize}
\item Filtrado de las hojas de visualización y preprocesado según el
  tipo de documento actualmente abierto.

\item Búsqueda mediante consultas XPath arbitrarias para usuarios
  avanzados. Marcado de nodos coincidentes en una búsqueda en la vista
  de árbol.

\item Creación de nuevos tipos de documento en la propia interfaz.

\item Crear nuevas hojas para otros formatos basados en \ac{XML}, como
  las trazas de ejecución del motor \ac{XSLT} Saxon, los ficheros de
  proyecto de GNOME Planner, o las demostraciones de los sistemas
  Mizar~\cite{Urban05} o Prover9
  (\url{http://www.cs.unm.edu/~mccune/mace4/}).

\item Cambio de la biblioteca Xalan a Saxon, pasando de \ac{XSLT} 1.0
  a \ac{XSLT} 2.0, que incorpora muchas nuevas funcionalidades.

\item Mejora del motor \ac{XHTML}/\ac{CSS}. Se evaluarán los motores
  del proyecto Lobo (ver~\url{http://lobobrowser.org/}), que añade
  soporte para JavaFX, y del proyecto Flying Saucer
  (\url{https://xhtmlrenderer.dev.java.net}), aparentemente más maduro
  y fácil de integrar. JavaFX podría ser un nuevo formato de
  visualización que permitiría crear interfaces Swing completas.

\item Integración de lenguajes de \emph{scripting} en el interior de
  las hojas \ac{XSLT}, para poder implementar funcionalidad adicional
  de manera más sencilla y sin modificar \visor{}.

\item Publicación de documentos con visualizaciones \ac{XHTML} del
  árbol y los nodos seleccionados, posiblemente integrando capacidades
  de búsqueda. Idealmente, publicar el documento debería producir una
  carga mínima en la máquina que lo sirviera.

\item Creación de un ejecutable para Windows mediante Launch4J
  (\url{http://launch4j.sourceforge.net/}).

\item Creación de una versión lanzable desde el navegador mediante
  Java WebStart.

\item Envío de los paquetes Debian al repositorio oficial.

\item Traducción completa del código al inglés.

\end{itemize}

\subsection{\nombrepostprocesador{}}

\begin{itemize}
\item Extracción de información de la salida de mayor variedad de
  eventos, como \orden{defaxiom} o \orden{verify-guards}, y de órdenes
  que se expandan a eventos, como \orden{make-event} o cualquier uso
  de una macro Lisp.

\item Mayor cantidad de información generada automáticamente, como por
  ejemplo sumarios globales.

\item En paralelo con el requisito anterior, aumento de la variedad y
  potencia de las hojas de visualización y preprocesado.

\item Integración con la ayuda \ac{HTML} de \ac{ACL2}.

\item Envío de los paquetes Debian al repositorio oficial.

\item Envío de la distribución al repositorio \ac{CPAN}.

\item Traducción completa del código al inglés.

\end{itemize}

\subsection{\nombreyaxml{}}

\begin{itemize}
\item Implementación de hojas de visualización y preprocesado para
  diversos lenguajes basados en \ac{YAML}.

\item Depuración del procesado de anclas, alias y etiquetas.

\item Soporte de \ac{YAML} 1.2 cuando quede finalizado (actualmente se
  halla en estado de borrador).

\item Envío del paquete Debian al repositorio oficial.

\item Envío del módulo al repositorio \ac{CPAN}.

\end{itemize}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../memoria"
%%% End: 
