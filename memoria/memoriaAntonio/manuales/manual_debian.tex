%
% Generado automáticamente por las hojas de estilo XSLT
% Retocado manualmente
%
% Antonio García Domínguez, (C) 2008
% nyoescape@gmail.com
%

\section{Introducción}

\subsection{¿Qué es un paquete Debian?}

 Un paquete Debian, en principio, no es más que un fichero comprimido que contiene los ficheros de la aplicación, cierta información adicional y un par de guiones específicos de apoyo. A través de un paquete Debian, podemos instalar de forma muy sencilla cualquier software que necesitemos, sin tener que entrar en detalles de cómo está hecha o cómo se configura inicialmente la aplicación. 

 Además, la información adicional contenida en dicho paquete permite al sistema que se ocupa de gestionarlos (\application{dpkg}) mantener un control de las dependencias. Así, si instalamos una determinada aplicación, todas las bibliotecas requeridas por ésta serán automáticamente instaladas. El robusto control de dependencias del sistema de empaquetado de Debian es precisamente uno de sus puntos más fuertes frente a otros sistemas de empaquetado, como \application{RPM} (Red Hat Package Manager). 

\subsection{¿Por qué se desarrollan paquetes?}

 Uno podría preguntarse las razones detrás del desarrollo de un paquete: ¿no podríamos simplemente compilar nosotros mismos el código? Efectivamente, podríamos, pero existen una serie de factores que hacen poco factible dicho enfoque: 

\begin{itemize}
\item \emph{Compilar lleva tiempo, y esfuerzo}: además del considerable tiempo de CPU requerido para compilar cualquier aplicación con un nivel mínimo de complejidad, hay que pensar en sus dependencias. Éstas son transitivas, con lo que tendremos que compilar una biblioteca que sea usada por otra biblioteca que sí use directamente el programa que queremos. 

 Un ejemplo extremo puede ser el conocido reproductor multimedia \application{mplayer}, cuyas dependencias se extienden de forma recursiva a lo largo de decenas de bibliotecas, en una versión con toda la funcionalidad activada. 

 También hay que pensar en los sistemas <<exóticos>> de compilación que algunos sistemas usan: no siempre tenemos la suerte de contar con sistemas estándar como el de las autotools, donde sabemos de antemano que basta con hacer esto en el 80 \% de los casos: 

\begin{alltt}
./configure
make
make install
\end{alltt}

\item \emph{Falta de uniformidad}: Supongamos que ya hemos compilado todo. ¿Cómo instalamos el programa? No existe un enfoque uniforme a lo largo del gran número y variedad de aplicaciones existentes: cada proyecto es un mundo. Tampoco sabemos en principio cómo configurarlo. 

 Además, es muy probable que el programa en su estado actual no esté pensado para ser instalado de dicha forma: puede que haya rutas escritas directamente en el código, o que se hagan ciertas suposiciones poco estándares. 

 Más aún: ¿y las asociaciones de fichero? ¿Y la entrada del menú? ¿Estarán bien hechas, y funcionarán bajo todos los entornos de escritorio? ¿Se podrá desinstalar el programa? 

\end{itemize}

 En resumen, podría decirse que la utilidad de un paquete Debian se halla en garantizar una experiencia de instalación cómoda y uniforme a lo largo de todo el software disponible, independientemente de cómo esté hecho. Así, se pone algo de orden al problema que se presenta ante la gran configurabilidad y heterogeneidad que presentan los sistemas GNU/Linux. 

 De todas formas, para no perder la libertad que tenemos al descargar el código fuente, podemos instalar no un paquete con los ejecutables y bibliotecas compilados, sino con su código fuente adaptado para nuestra distribución. Son los paquetes de código fuente (\emph{source packages}): normalmente se usan cuando queremos compilar partiendo de la misma base que el paquete binario de nuestra distribución. 

 Por ejemplo: el paquete \filename{kernel-source-2.4.27} contiene el código fuente de la versión del kernel de Linux que emplea Debian. Este código trae de por sí una serie de modificaciones que lo diferencian del kernel que podríamos bajarnos de la página oficial, y se halla ya configurado con las mismas opciones que nuestro propio kernel. 

\subsection{¿Quién desarrolla paquetes?}

 Así, vemos que hacer un paquete no es algo trivial, pudiendo requerir todo tipo de cambios a un programa. Sin embargo, su conveniencia les hace imprescindibles: no podemos esperar obtener un número aceptable de usuarios a menos que nuestro software sea fácil de instalar, configurar y usar. 

 Por ello, tendremos que distinguir entre dos roles, que podrán ser cubiertos por las mismas o distintas personas: 

\begin{itemize}
\item  Equipo de desarrollo del programa en sí (equipo original de desarrollo o \emph{upstream}): son los que realmente se ocupan de añadir funcionalidad y corregir errores. El vocablo inglés, cuyo significado es <<río arriba>>, hace referencia al hecho de que las nuevas funciones <<fluyen>> de este equipo hacia nuevas revisiones del paquete. 

\item  Desarrolladores del paquete: son los que deben adaptar el programa al sistema de empaquetado, controlar las dependencias, y en resumen, hacer que el programa se integre bien con el resto del sistema. Sobre todo en las primeras versiones, es posible que tenga que hacer cambios o mejoras al código de la aplicación, que tendrá que discutir con el equipo original de desarrollo. 

 Es frecuente que un paquete vaya pasando por distintos responsables, y que haya todo un equipo detrás y no sólo un responsable (como en el caso del Ubuntu MOTU Team\footnote{Es el responsable de mantener los paquetes de los repositorios \emph{universe} y \emph{multiverse} de Ubuntu.}, y se halla formado sobre todo por usuarios de dicha distribución). 

\end{itemize}

\subsection{Notas acerca de esta guía}

 Escribí esta guía para recoger cierta información que anda dispersa por la Red, y parte de mi (poca) experiencia como la combinación de un repositorio \application{reprepro} con sistemas de versionado y demás. 

 Existen otras guías, fantásticas sin duda, como~\cite{packagingcomplete}. No intento reemplazarlas, sino complementarlas con más información de otros tipos que podría ser útil, como, por ejemplo, como conseguir tener fácilmente nuestro propio repositorio. 

\section{Preparativos}

 Antes de empezar a crear nuestro primer paquete, vamos a preparar el entorno con todas las herramientas que necesitaremos. Por supuesto, si no deseamos distribuir nuestro paquete a través de Internet, o gestionar varios paquetes dependientes entre sí, no nos será realmente necesario crear un repositorio local y publicarlo bajo un servidor Web. 

\note{A lo largo de esta guía, supongo que el usuario empleará Ubuntu Linux <<Gutsy Gibbon>> 7.10. Las órdenes exactas podrían variar ligeramente, pero por lo general todo debería funcionar en cualquier sistema basado en Debian.}

\subsection{Cómo instalar las herramientas básicas}

 En primer lugar, requeriremos ciertas herramientas para empezar a desarrollar paquetes Debian. Para ello, ejecutaremos (como haremos a lo largo de esta guía) bajo una terminal de texto, como la disponible desde el menú principal en \emph{Aplicaciones $\rightarrow$ Accesorios $\rightarrow$ Terminal}, la siguiente orden: 

\begin{verbatim}
sudo aptitude install cdbs debhelper autotools-dev fakeroot \
     desktop-file-utils linda lintian devscripts dh-make \
     debian-policy automake-1.9 autoconf
\end{verbatim}

 Posteriormente a lo largo de este manual iremos describiendo para qué sirven algunos de estos paquetes. Adelantaremos algunos usos útiles de \application{dpkg}, que después nos serán de mucha ayuda: 

\begin{description}
\item[\nohyphens{\texttt{\command{dpkg} -l \emph{patrón}}}] \mbox{}
 Permite buscar paquetes que cumplan un cierto patrón. Así, \command{dpkg -l '*sdl*'} nos buscará todos los paquetes relacionados con la biblioteca SDL. Es importante usar comillas simples, para evitar que una posible sustitución automática del shell interfiera con la orden. 

\item[\nohyphens{\texttt{\command{dpkg} -L \emph{paquete}}}] \mbox{}
 Lista todos los ficheros de un paquete determinado. 

\item[\nohyphens{\texttt{\command{dpkg} -S \emph{fichero}}}] \mbox{}
 Esta orden es muy útil: lista el paquete al cual pertenece un determinado fichero del sistema. 

\item[\nohyphens{\texttt{\command{dpkg-deb} -c \emph{fichero}}}] \mbox{}
 Lista los contenidos de un paquete Debian. Útil para comprobar que todo está en su lugar. 

\item[\nohyphens{\texttt{\command{dpkg-deb} -x \emph{fichero}\emph{ruta}}}] \mbox{}
 Extrae los contenidos del paquete Debian a la ruta que le indiquemos. 

\item[\nohyphens{\texttt{\command{dpkg-deb} -e \emph{fichero}}}] \mbox{}
 Extrae el directorio de control \filename{DEBIAN} de un paquete. Así podemos ver los guiones de postinstalación y postdesinstalación, por ejemplo, y otra información de interés. 

\end{description}

\subsection{Cómo conseguir paquetes limpios}
\label{paqueteslimpios}
 Normalmente, desarrollamos el paquete Debian dentro de nuestro sistema habitual. Esto quiere decir que en nuestro sistema ya habrá un gran número de paquetes instalados por nosotros mismos. ¿Cómo podemos asegurarnos de que no hemos olvidado alguna dependencia? Peor aún: ¿se está compilando el programa con las bibliotecas que debiera, o está usando alguna versión que nosotros olvidamos haber instalado hace ya tiempo? 

 En el sistema de empaquetado Debian, estos problemas se resuelven creando e instalando el paquete no dentro del propio sistema, sino de una imagen de un sistema <<limpio>>, sin otros paquetes que los esenciales. Dicha imagen se conoce como una \emph{jaula \application{chroot}}, a partir de la aplicación del mismo nombre, que nos <<encierra>> dentro de un árbol de directorios, haciéndonos pensar de forma temporal que se trata del sistema de ficheros completo. 

 Adicionalmente, el uso de esta jaula nos permite probar el proceso de instalación completo una y otra vez sin peligro de dañar a nuestro sistema, y evitar posibles conflictos que puedan surgir. 

 Aunque nosotros mismos podríamos (con el suficiente tiempo y esfuerzo) hacernos una jaula y ejecutar las órdenes de construcción en ella manualmente, la mejor opción es hacer uso de alguna serie de guiones escritos específicamente para la construcción de paquetes Debian en éstas. Básicamente, lo que hacen es añadir el proceso de entrada y salida de la jaula sobre lo que ya hacen otros guiones como \application{dpkg-buildpackage} y \application{debuild}. 

 En principio, con \application{pbuilder} nos bastaría. Sin embargo, tiene un problema: la imagen que crea es simplemente un gran fichero \filename{tar.gz}, que descomprime cada vez que construimos el paquete. Esto hace que sea mucho más lento que una construcción habitual. Lo combinaremos con \application{cowdancer}, que usa un mecanismo de \emph{copy-on-write}\footnote{Este mecanismo usa el árbol de directorios original directamente en un principio, y realiza todas las posteriores escrituras sobre copias de los originales, para mantener el árbol de directorios original limpio, y no tener que realizar una lenta copia completa por otro lado.} para evitarlo, reduciendo en gran medida dicha sobrecarga. 

 Así, los pasos a seguir son: 

\begin{enumerate}
\item  Instalamos los dos paquetes que necesitamos, junto con sus dependencias: 

\begin{alltt}
sudo aptitude install pbuilder cowdancer
\end{alltt}

\item  Generamos de forma automatizada la imagen del sistema Ubuntu con la siguiente orden. Este proceso puede llevar bastante tiempo: tiene que descargar un Ubuntu mínimo a través de la red. 

\begin{alltt}
sudo cowbuilder --create \textbackslash{}
 --othermirror \textbackslash{}
 "deb http://archive.ubuntu.com/ubuntu gutsy universe multiverse"
\end{alltt}

\item  Tras un buen rato, nuestra imagen estará lista. Añadimos las siguientes líneas al fichero \filename{\~{}\{\}/.pbuilderrc}: 

\begin{alltt}
\# Seleccionamos los componentes de Ubuntu 
\# (son distintos a los de Debian, que son 
\#  main, contrib y non-free)
COMPONENTS="main universe multiverse"

\# Uso de cowbuilder en vez de pbuilder normal (más rápido)
export PDEBUILD\_PBUILDER=cowbuilder

\# Aqui pondremos nuestro correo como desarrollador de 
\# paquetes
export DEBEMAIL="tudireccion@decorreo"
\end{alltt}

\end{enumerate}

\subsection{Cómo simplificar la distribución}

 Supongamos que alguien quiere instalar nuestro paquete. ¿Cómo lo consigue? ¿Se lo descarga de alguna web, teniendo que buscar una y otra vez cada vez que necesite algo? ¿Tendrá el cliente que comprobar una y otra vez dicha página web, o tendrá el desarrollador de la aplicación que implementar algún mecanismo de actualización automática, aunque sólo se trate de un guión Perl? No olvidemos que, además, en el caso de una distribución GNU/Linux, podemos tener miles de paquetes instalados (1646 en mi caso, retirando los paquetes esenciales). No parece factible simplemente descargarlo de alguna página web. 

 En realidad lo que se hace es agrupar los paquetes en repositorios. Se conoce como \emph{repositorio Debian} a un árbol de directorios con una cierta estructura, desde el que el sistema de empaquetado de software de Debian, \application{dpkg}, pueda instalar software. Dicho repositorio puede estar disponible de forma local en nuestro disco duro, como el que haremos aquí, o en otra máquina que aloje un servidor HTTP (web) o FTP. 

 Este paso sólo es estrictamente necesario cuando tengamos que construir nosotros mismos varios paquetes que dependan entre sí. De todas formas, recomiendo seguirlo, ya que nos permite depurar ciertas cosas como que el paquete se halle correctamente firmado y nuestra clave pública bien distribuida. Además, podemos usarlo para actualizar a partir de él nuestra versión instalada del mismo paquete, y así reproducir exactamente lo que un usuario normal vería. 

 Podríamos gestionar manualmente el contenido del repositorio a través de las herramientas del paquete \filename{apt-utils}, pero por simplicidad, usaremos el sistema \application{reprepro} (anteriormente \application{mirrorer}) para gestionar todo el proceso. 

 Seguiremos estos pasos: 

\begin{enumerate}
\item Instalamos el paquete correspondiente con:

\begin{alltt}
sudo aptitude install reprepro
\end{alltt}

\item Creamos el repositorio dentro de \filename{/var/\-packages/\-ubuntu}:

\begin{alltt}
sudo mkdir -p /var/packages/ubuntu/conf
\end{alltt}

\item  Situamos en el fichero \filename{/var/\-packages/\-ubuntu/\-conf/\-distributions} las siguientes líneas: 

\begin{alltt}
Origin: \emph{Mi Nombre}
Label:  \emph{Mi Nombre}
Codename: gutsy
Architectures: i386 source
Components: main
Description: \emph{Mi propio repositorio}
\end{alltt}

 Como vemos, tenemos una distribución, \emph{gutsy}, que contiene paquetes binarios para la arquitectura IA-32 (Intel 80386 o superior) y paquetes de código fuente repartidos en un único componente \emph{main}. 

\item  Ahora ya podemos manipular el repositorio de distintas formas. Posteriormente veremos cómo obtener los ficheros \filename{.deb} y \filename{.dsc}. Por ejemplo: 

\begin{itemize}
\item Añadimos paquetes binarios con:

\begin{alltt}
sudo reprepro -b /var/packages/ubuntu \textbackslash{}
     includedeb gutsy \emph{(fichero .deb)}
\end{alltt}

\item Añadimos paquetes de fuentes con:

\begin{alltt}
sudo reprepro -b /var/packages/ubuntu \textbackslash{}
     includedsc gutsy \emph{(fichero .dsc)}
\end{alltt}

\item Retiramos un paquete mediante:

\begin{alltt}
sudo reprepro -b /var/packages/ubuntu \textbackslash{}
     remove gutsy \emph{(nombre)}
\end{alltt}

\end{itemize}

\end{enumerate}

\subsection{Control de versiones}

 Todo desarrollo de software se puede beneficiar del uso de un sistema de control de versiones. A través de éste, podremos siempre acceder a todas las versiones realizadas en el pasado de cualquier fichero, y mantener múltiples copias de trabajo siempre sincronizadas. Son especialmente importantes en proyectos de software libre, donde puede haber potencialmente muchos participantes. 

 Además, el uso explícito de un sistema de control de versiones elimina una molestia a la hora de desarrollar paquetes Debian: la avalancha de ficheros que tendríamos que gestionar de otra forma, con ficheros \filename{tar.gz} (más conocidos como \emph{tarballs}), parches y demás que habrá que mantener versión a versión. 

 Como siempre, existe una gran variedad, pero en este caso elegí Subversion, descendiente a nivel conceptual del conocido CVS, por su excelente documentación, estabilidad y simplicidad. Adicionalmente, podremos hacer uso de un conjunto de guiones de ayuda desarrollados por la comunidad Debian, que nos ayudan a estandarizar un poco la estructura del repositorio. 

\note{ Para los preocupados por su espacio en disco: el enfoque seguido por Subversion, al igual que en la mayoría de los sistemas de control de versiones, es mucho más eficiente que lo que nosotros podríamos hacer simplemente guardando todas las versiones. Sólo guarda, comprimidos, los cambios de una versión a otra. }

 El proceso de preparación de nuestro propio repositorio de Subversion y una copia de trabajo local es sencillo: 

\begin{enumerate}
\item Instalamos Subversion y el paquete de desarrollo de paquetes (valga la redunancia) bajo repositorios Subversion:

\begin{alltt}
sudo aptitude install subversion svn-buildpackage
\end{alltt}

\item Creamos el repositorio central en \filename{\~{}/\-.svnDebian}:

\begin{alltt}
svnadmin create .svnDebian
\end{alltt}

\item  Ahora creamos una copia de trabajo, sobre la que crearemos y modificaremos ficheros, que luego enviaremos al repositorio central para que otras personas puedan propagar los cambios a sus propias copias de trabajo: 

\begin{alltt}
svn checkout \textbackslash{}
    file:///home/minombredeusuario/.svnDebian packages
\end{alltt}

\end{enumerate}

 Por lo pronto, no haremos nada más: la estructura de nuestro repositorio será generada de forma automática, y diferirá ligeramente de la estándar que el libro de Subversion describe. 

 A título de referencia para la fase de creación, he aquí algunas de las órdenes que podemos usar dentro de una copia de trabajo. Para más información, referirse al libro electrónico~\cite{svnhandbook}. 

\begin{description}
\item[\nohyphens{\texttt{\command{svn add} \emph{fichero}}}] \mbox{}
Marca un fichero o directorio para añadir al repositorio.

\item[\nohyphens{\texttt{\command{svn rm} \emph{fichero}}}] \mbox{}
Marca un fichero o directorio para eliminar del repositorio.

\item[\nohyphens{\texttt{\command{svn mv} \emph{fichero} \emph{ruta}}}] \mbox{}
Mueve un fichero o directorio a otra ruta. El fichero o directorio no debe haber sufrido modificaciones desde su último envío.

\item[\nohyphens{\texttt{\command{svn cp} \emph{fichero} \emph{ruta}}}] \mbox{}
Copia un fichero o directorio a otra ruta. El fichero o directorio no debe haber sufrido modificaciones desde su último envío.

\item[\nohyphens{\texttt{\command{svn mkdir} \emph{directorio}}}] \mbox{}
Crea un nuevo directorio y lo añade al repositorio.

\item[\nohyphens{\texttt{\command{svn commit} -m \emph{mensaje}}}] \mbox{}
Confirma todos los cambios hechos hasta el momento, y los envía al repositorio, registrando el envío con el mensaje que hayamos proporcionado. Tiene semántica transaccional: el envío se produce por completo, o no se produce en absoluto.

\item[\nohyphens{\texttt{\command{svn status}}}] \mbox{}
Muestra el estado de todos los ficheros bajo el árbol actual, con una letra antes de su ruta. Algunas de las que pueden aparecer son:

\begin{description}
\item[?] \mbox{}
No pertenece al repositorio (quizás habría que añadirlo con \command{svn add}).

\item[A] \mbox{}
 El fichero va a ser añadido en el próximo envío. 

\item[D] \mbox{}
 El fichero va a ser borrado en el próximo envío. 

\item[M] \mbox{}
 El fichero ha sido modificado desde el último envío. 

\end{description}

\item[\nohyphens{\texttt{\command{svn export} \emph{rutaDirOrigen} \emph{rutaDestino}}}] \mbox{}
Exporta el directorio origen, que forma parte de una copia de trabajo, a la ruta destino, retirando todos los ficheros usados por Subversion. Muy útil cuando queremos redistribuir código, por ejemplo, y no la copia de trabajo entera.

\end{description}

\subsection{Autenticación}

 Sólo nos queda una cosa más para tener el entorno completamente listo antes de desarrollar nuestro paquete Debian: preparar nuestra firma digital personal. Adicionalmente, la integraremos con nuestro repositorio local, y usaremos un agente de claves para evitar escribir una y otra vez su contraseña a la hora de construir el paquete. 

 ¿Por qué querríamos usar una? No olvidemos que estamos haciendo un paquete que efectivamente va a ser instalado en el sistema final bajo la propiedad del superusuario. Una persona malintencionada podría manipular los contenidos del paquete y comprometer a los sistemas que lo instalen, añadiendo \emph{rootkits} o puertas traseras entre nuestros ficheros. 

 Para un usuario muy centrado en seguridad, el mayor nivel de seguridad obtenible con un nivel razonable de esfuerzo, sin llegar a tener que analizar en profundidad el código, sería directamente descargar el código de alguna fuente fiable, y comprobar su integridad mediante algún algoritmo de \emph{hashing}. Lo más común es encontrar \emph{checksums} MD5, que aunque no criptográficamente seguros, son rápidos de calcular, y cumplen el propósito original de evitar descargas corruptas. 

 No llegaremos a esos extremos. En lugar de eso, aprovecharemos una de las aplicaciones de los algoritmos de cifrado asimétrico. En ellos, todo usuario tiene dos claves: la pública, que damos a todo el mundo, y la privada. Si ciframos algo con una clave, se puede descifrar con la otra. Así no nos hace falta transmitir la clave a la otra parte, como en los algoritmos tradicionales simétricos. En particular, si ciframos algo con nuestra clave privada, y el usuario lo descifra con nuestra clave pública, éste puede estar seguro que el paquete es auténtico. 

 Dado que cifrar todo un paquete puede ser potencialmente muy costoso, lo que se suele hacer es cifrar el resultado de alguna función de hash aplicada sobre el fichero, como SHA-1 o alguna variante criptográficamente más fuerte. De hecho, en los repositorios Debian, se va un paso más allá: sólo se firma el fichero central con el listado de los paquetes disponibles, sus tamaños y sus \emph{checksums} MD5, para tener el menor impacto posible en rendimiento. En nuestra configuración, se trata de \filename{/var/\-packages/\-ubuntu/\-dists/\-gutsy/\-Release}, y su firma se halla en \filename{/var/\-packages/\-ubuntu/\-dists/\-gutsy/\-Release.gpg}. 

 El proceso de instalación es algo más elaborado que en los anteriores casos, dado que se extiende a lo largo de unos cuantos ficheros de configuración: 

\begin{enumerate}
\item  Primero instalamos los paquetes que necesitamos: \filename{gnupg} implementa la funcionalidad de cifrado en sí, \filename{gnupg-agent} es el agente ocupado de almacenar temporalmente nuestra contraseña y \filename{pinentry-gtk2} nos permite usar un diálogo gráfico para introducir la contraseña, en vez de usar la terminal: 

\begin{alltt}
sudo aptitude install gnupg gnupg-agent pinentry-gtk2
\end{alltt}

\item  Ahora generaremos nuestro par de claves, siguiendo las instrucciones que se nos irán indicando: 

\begin{alltt}
gpg --gen-key
\end{alltt}

 El campo de correo electrónico es muy importante para el resto de pasos, y debe coincidir con el que usamos anteriormente en DEBEMAIL (ver sección~\ref{paqueteslimpios} (página~\pageref{paqueteslimpios})). 

\item  Añadiremos los ajustes necesarios al agente de GnuPG, en el fichero \filename{\~{}/.gnupg/\-gpg-agent.conf}: 

\begin{alltt}
pinentry-program /usr/bin/pinentry-gtk-2
no-grab
default-cache-ttl 1800
\end{alltt}

 Así, sólo tendremos que introducir nuestra contraseña cada 30 minutos como mucho, y emplearemos una interfaz gráfica basada en GTK 2.0 (estilo GNOME). 

\item  Hemos de indicar a GnuPG que haga uso del agente para pedir la contraseña de la clave privada. Hay que descomentar la siguiente línea de \filename{\~{}/\-.gnupg/\-gpg.conf}: 

\begin{alltt}
use-agent
\end{alltt}

\item  Al instalar el paquete \filename{gnupg-agent} se nos añadió el script necesario para su arranque en \filename{/etc/\-X11/\-Xsession.d/\-90gpg-agent}. Hemos de reiniciar el servidor X, saliendo de nuestra sesión y pulsando \texttt{CTRL + ALT + Retroceso}. 

\item  Debemos decirle a \application{reprepro} que use dicha clave para firmar los paquetes. Añadiremos la siguiente línea con el email que usamos en la clave GPG a \filename{/var/\-packages/\-ubuntu/\-conf/\-distributions}: 

\begin{alltt}
SignWith: <\emph{tudireccion@decorreo}>
\end{alltt}

\item  Por último, hemos de exportar nuestra clave pública a un fichero, para poder pasársela a los demás, y añadirla a la lista de claves confiables de \application{apt}: 

\begin{alltt}
gpg -a --export \emph{tudireccion@decorreo} > claveDebian.asc
sudo apt-key add claveDebian.asc
sudo cp claveDebian.asc /var/packages
\end{alltt}

\end{enumerate}

\subsection{Distribución a través de Internet}

\subsubsection{Instalación del servidor}

 Podemos aprovechar nuestro repositorio local para distribuir nuestros paquetes a través de la red, simplemente publicando el directorio \filename{/var/\-packages} bajo un servidor HTTP o FTP. En particular, aquí veremos cómo hacerlo con el servidor Apache 2. 

 Evidentemente, hacerlo o no es completamente opcional. Los pasos a seguir son: 

\begin{enumerate}
\item  Si no tenemos una dirección IP estática, podemos en su lugar registrarnos en sitios como no-ip (\url{http://www.no-ip.org}) o DynDNS (\url{http://dyndns.com}), donde conseguiremos un nombre de dominio que actualizaremos periódicamente con nuestra IP. 

\item  Ahora hemos de asegurarnos de que el puerto 80 por TCP se halle accesible, cambiando los ajustes del cortafuegos y del encaminador en caso de que usemos NAT (Network Address Translation). Con Ubuntu recién instalado, el cortafuegos no tendrá ninguna regla definida, por lo que en principio no habría que hacer nada en cuanto a la configuración del servidor. 

\item  Instalamos el servidor Apache mediante: 

\begin{alltt}
sudo aptitude install apache2
\end{alltt}

\item  Crearemos el fichero \filename{/etc/\-apache2/\-sites-available/\-repoDebian}, con el siguiente contenido, donde sustituiremos la dirección de nuestro servidor y el correo que empleamos en la firma GPG: 

\begin{alltt}
<VirtualHost *:80>
        ServerAdmin tudireccion@decorreo

        DocumentRoot /var/packages
        ServerName \emph{direccion.delservidor.org:80}
        ErrorLog /var/log/apache2/error.log

        LogLevel warn

        CustomLog /var/log/apache2/access.log combined
        ServerSignature On

        \# Permite que la gente navegue por el directorio
        <Directory "/var/packages">
                Options Indexes FollowSymLinks MultiViews
                DirectoryIndex index.html
                AllowOverride Options
                Order allow,deny
                allow from all
        </Directory>

        \# Oculta el directorio conf
        <Directory "/var/packages/*/conf">
                Order allow,deny
                Deny from all
                Satisfy all
        </Directory>

        \# Oculta el directorio db
        <Directory "/var/packages/*/db">
                Order allow,deny
                Deny from all
                Satisfy all
        </Directory>
</VirtualHost>
\end{alltt}

\item  Activaremos dicha página web y desactivaremos la página por defecto: 

\begin{alltt}
cd /etc/apache2/sites-enabled
sudo a2dissite default
sudo a2ensite repoDebian
\end{alltt}

\item  Reiniciamos el servidor mediante: 

\begin{alltt}
sudo /etc/init.d/apache2 restart
\end{alltt}

\item  ¡Listo! Habría que probar a cargar en un navegador la dirección \url{http://127.0.0.1/} y ver que todo coincide. 

\end{enumerate}

\subsubsection{Instrucciones para un usuario de nuestro paquete}

 Ahora nos pondremos por un momento en la piel de un usuario de nuestro paquete. ¿Cómo podría tener nuestro paquete siempre a la última, con la seguridad de que es la versión genuina? 

 En este caso, vamos a intentar hacerlo todo a través de interfaces gráficas, más amigables para un usuario medio. Recomiendo añadirnos a nosotros mismos como un cliente más, para facilitar la depuración. Sólo tendríamos que sustituir nuestro nombre de host real con \filename{127.0.0.1} en el resto de instrucciones, o mejor aún, añadir la siguiente línea a \filename{/etc/\-hosts}, reemplazando la que tuviera la misma dirección si hubiera alguna: 

\begin{alltt}
127.0.0.1 localhost \emph{direccion.delservidor.org}
\end{alltt}

En primer lugar, el usuario debe de haber descargado el fichero
\url{http://direccion.delservidor.org/claveDebian.asc} que exportamos
antes, con nuestra clave pública.

 Accederemos, a partir de la barra de programas en la parte superior de la pantalla, al elemento \emph{Sistema $\rightarrow$ Administración $\rightarrow$ Orígenes de software}. 

 En el diálogo que aparece, pasamos a la pestaña \emph{Software de
	terceros}, cuyo aspecto será similar al de la figura . 

\begin{figure}
\centering
\includegraphics[width=.5\textwidth]{manuales/pestFuentes.png}
\caption{Pestaña de Software de Terceros}
\label{pestFuentes}
\end{figure} Pulsaremos en el botón \command{Añadir} una primera vez, y pegaremos la siguiente línea: 

\begin{alltt}
deb http://\emph{tunombre.deservidor.org}/ubuntu gutsy main
\end{alltt}

 Volvemos a pulsarlo, y ahora introducimos ésta, correspondiente a un repositorio de paquetes de código fuente (de ahí el \emph{deb-src}): 

\begin{alltt}
deb-src http://\emph{tunombre.deservidor.org}/ubuntu gutsy main
\end{alltt}

 Cambiamos a la pestaña \emph{Autentificación}, que será parecida a la de la figura , y pulsamos \command{Importar clave}. Seleccionaremos el fichero \filename{claveDebian.asc} antes descargado. 

\begin{figure}
\centering
\includegraphics[width=.5\textwidth]{manuales/pestAutentificacion.png}
\caption{Pestaña de Autentificación}
\label{pestAutentificacion}
\end{figure} Guardamos los cambios realizados pulsando \command{Cerrar}, y finalmente pulsamos el botón \command{Recargar} de la barra de herramientas de la ventana principal. Cuando se cierre automáticamente el diálogo que aparece, ya podremos usar como siempre \application{Synaptic}, empleando el botón \command{Buscar} para hallar el paquete que deseamos, marcarlo con un doble clic e instalarlo mediante \command{Aplicar}. Además, a partir de ahora, el sistema \application{apt} se ocupará de monitorizar dicho repositorio y mantener actualizado el sistema. 

\section{Creación y mantenimiento del paquete}

 En este capítulo, daré un ejemplo de un paquete razonablemente sencillo, pero completo: un emulador de SNES, conocido como ZSNES. Veremos todas las fases, desde que nos descargamos el código fuente hasta que tenemos el paquete instalado en nuestro sistema y funcionando. Existen muchas guías de creación de paquetes, pero en mi opinión la información se halla bastante fragmentada. De todas formas, en el wiki de Ubuntu hay una excelente introducción acerca del tema~\cite{packagingcomplete}, y también hay una guía por parte de la comunidad Debian~\cite{debianmaintainer}, aunque en mi opinión la de Ubuntu está más actualizada. 

 Para simplificar, describiré el proceso de forma secuencial. Sin embargo, lo normal es que sea iterativo, teniendo muchas revisiones intermedias del paquete hasta dejarlo listo para su distribución. Se ven aspectos más avanzados en el siguiente capítulo. 

\subsection{Adaptaciones previas al uso de Subversion}

\subsubsection{Creación de un esqueleto}

 Antes de poder introducir los ficheros fuente de nuestro paquete en el repositorio Subversion que previamente preparamos, hemos de crear una primera versión de nuestro paquete. 

 Tras descargar el código fuente de la página
	oficial (\url{http://www.zsnes.com/index.php?page=files}) a \filename{/tmp/\-packages/\-zsnes151src.tar.bz2}, crearemos el esqueleto básico del paquete mediante \command{dh\_make}, una de las muchas herramientas del paquete \application{debhelper} de ayuda. Ejecutaremos las siguientes órdenes en una terminal dentro del directorio \filename{/tmp/\-packages}: 

\begin{alltt}
tar -xjf zsnes151src.tar.bz2
mv zsnes\_1\_51 zsnes-1.510
cd zsnes-1.510
dh\_make -e \emph{tudireccion@decorreo} -c GPL -s --createorig
      
\end{alltt}

 La carpeta que hemos creado (\filename{zsnes-1.510}) obedece al convenio seguido por Debian \filename{nombrepaquete-versionUpstream}, donde la versión del programa original se entiende como una serie de números separados por puntos: así, \filename{zsnes-1.510} es más reciente que \filename{zsnes-1.6}, y menos que \filename{zsnes-1.600}. 

 Por otro lado, las opciones pasadas a \command{dh\_make} son: 

\begin{description}
\item[-e tudireccion@decorreo] \mbox{}
 Especifica nuestra dirección email como desarrollador del paquete. Se usa en el registro de cambios (de ahora en adelante el \emph{Changelog}), y para realizar firmas digitales. 

\item[-c GPL] \mbox{}
 Indica que el código original sigue la General Public License. Otras opciones incluyen la LGPL, BSD o la licencia artística. En otro caso, se nos dejará un hueco (posteriormente veremos dónde) para que lo rellenemos con el texto de la licencia en cuestión. 

\item[-s] \mbox{}
 Existen varios tipos de paquete Debian: de un solo binario, de varios, bibliotecas, o paquetes que emplean CDBS (el resto usan únicamente \application{debhelper}). Aquí hemos decidido hacer un paquete de un solo binario, mediante debhelper. Después veremos también cómo hacer un paquete con CDBS. 

\item[--createorig] \mbox{}
 Creamos en el directorio padre un fichero \filename{zsnes\_1.510.orig.tar.gz} con el código fuente original, para poder comparar con la versión que usemos al construir el paquete y volcar las diferencias a un fichero \filename{diff}. 

\end{description}

\subsubsection{Edición}

 Ya tenemos el esqueleto del paquete. Todos los ficheros específicos de él se hallan bajo el directorio \filename{/tmp/\-packages/\-zsnes-1.510/\-debian}. Si examinamos dicho directorio, veremos que hay un gran número de ficheros. No utilizaremos los ejemplos incluidos, indicados por la extensión \filename{.ex}, así que los retiraremos, junto con el fichero \filename{README.Debian}, dado que no hay nada especial acerca de nuestro paquete: 

\begin{alltt}
rm debian/*.{ex,EX} debian/README.Debian
\end{alltt}

 Iremos rellenando cada fichero de control en \filename{debian} con los datos necesarios. Iremos detallando su sintaxis y semántica a lo largo de esta sección. 

\paragraph{changelog}

 Éste es el registro de cambios de nuestro paquete. Aquí iremos indicando los cambios realizados a lo largo de cada versión del paquete, no del software original. Este fichero es el que nuestros usuarios leerán para ver qué hay de nuevo en cada versión del paquete. 

 Escribiremos nuestra primera entrada: 

{ \small
\begin{alltt}
zsnes (1.510-0ubuntu1) gutsy; urgency=low

  * Versión inicial del paquete

 -- Antonio Garcia <nyoescape@gmail.com>  Fri, 19 Feb 2008 13:49:12 +0100
\end{alltt}
}

 Vemos cómo la versión actual del paquete junto con su última fecha y autor del cambio se hallan codificados en el registro. También se tiene en cuenta la distribución (en nuestro caso \emph{gutsy}, de Ubuntu), y la urgencia del cambio (por lo general baja, a menos que se trata de una vulnerabilidad de seguridad o algo del estilo). 

 Para una misma versión del software original, tendremos distintas versiones del paquete, separadas del número de versión original por un guión, como vemos aquí. En particular, los paquetes de Ubuntu~\cite{ubuntuversioning} usan el esquema \varname{-XubuntuY}, indicando que se trata de la Y-ésima versión del paquete de Ubuntu originado de la X-ésima versión del paquete Debian (0 si no proviene de un paquete Debian). Los números de versión de paquete comienzan por 1. 

\note{ La razón de este esquema de versionado es para permitir una fácil integración con los paquetes Debian. Normalmente, la política de Ubuntu es sólo crear nuevos paquetes o versiones de éstos si el paquete Debian está anticuado o tiene algún problema. Así, si los de Debian sacan una nueva versión, como la \varname{-3}, a partir de \varname{-2ubuntu3}, se reflejará dicha información de forma correcta. }

 Así, para la próxima versión del paquete, sólo tendremos que añadir la entrada en cuestión al registro, y nuestros guiones de ayuda harán el resto del trabajo. 

\note{ Mucho cuidado con el formato del registro, es muy rígido. El espaciado debe ser exactamente el mismo que en el ejemplo, como los dos espacios entre la dirección de correo y la fecha, o el espacio inicial al inicio de la misma línea. }

\paragraph{compat}

 Para este fichero no hay que hacer nada: sólo contiene un número entero, indicando qué versión del paquete \application{debhelper} estamos usando. 

\paragraph{control}

 Este fichero es muy importante: describe todos los paquetes que estamos definiendo y enuncia sus dependencias. El formato es también bastante rígido, pero muy simple. Utiliza una serie de campos delimitados por ':' y saltos de línea. 

 Por supuesto, no existe ninguna receta mágica que nos diga las dependencias de un programa cualquiera. Para ello, normalmente tendremos que examinar la documentación del desarrollador original, y/o el guión de compilación que utilice: como aquí usan las \application{autotools}, podríamos consultar \filename{src/\-configure.in}. Una buena referencia respecto a las \application{autotools} es el Autobook~\cite{autobook}. 

 Por suerte, los desarrolladores de ZSNES han incluido dichas dependencias en \filename{docs/\-install.txt}, con lo que no tendremos que ir buscando en los guiones de compilación. 

 El fichero que usaremos será éste: 

\begin{alltt}
Source: zsnes
Section: games
Priority: optional
Maintainer: Antonio Garcia <nyoescape@gmail.com>
Build-Depends: cdbs, debhelper (>= 4.1.0), autotools-dev, fakeroot, 
  desktop-file-utils, g++ (>= 4), libsdl1.2-dev, nasm (>= 0.98), 
  zlib1g-dev (>= 1.2.3), libpng12-dev (>= 1.2), libncurses5-dev, 
  libgl1-mesa-dev
Standards-Version: 3.7.2

Package: zsnes
Architecture: i386
Depends: \${shlibs:Depends}
Description: Emulador de Super Nintendo
 Emulador de la consola Super Nintendo con más funciones 
 disponibles. Permite guardar y cargar estados, grabar 
 demostraciones, y aplicar diversos filtros. Tiene una 
 compatiblidad inmejorable.
\end{alltt}

\note{ En éste y en cualquier otro fichero de control de Debian, no debemos olvidar poner un salto de línea justo al final del fichero. }

 Examinando el fichero de campo a campo, tenemos: 

\begin{description}
\item[\computeroutput{Source: zsnes}] \mbox{}
Indica que el paquete fuente del que derivan todos se llama "zsnes".

\item[\computeroutput{Section: games}] \mbox{}
Por la política de Debian~\cite{debianpolicy}, todo paquete se halla en alguna sección de las disponibles. Así indicamos qué tipo de aplicación es: un juego, un editor, etc.

\item[\computeroutput{Priority: optional}] \mbox{}
 Indica la importancia del paquete: desde imprescindibles (\emph{required}), pasando por importantes (\emph{important}), estándar (\emph{standard}), opcionales (\emph{optional}), y extra (tienen conflicto con alguno de más prioridad). 

\item[\computeroutput{Maintainer: Antonio Garcia <nyoescape@gmail.com>}] \mbox{}
Nombre y dirección de contacto del desarrollador del paquete.

\item[\computeroutput{Build-Depends: ...}] \mbox{}
Paquetes requeridos para poder compilar este paquete. Incluye las herramientas para paquetes Debian y las dependencias del propio programa.

\item[\computeroutput{Standards-Version: 3.7.2}] \mbox{}
 Versión de la política de Debian que este documento sigue. Realmente se halla compuesta por varios documentos, todos situados bajo el directorio \filename{/usr/\-share/\-doc/\-debian-policy}. 

\item[\computeroutput{Package: zsnes}] \mbox{}
Nombre de uno de los paquetes binarios generados a partir del fuente. Aquí sólo hay uno y tiene el mismo nombre.

\item[\computeroutput{Architecture: i386}] \mbox{}
Arquitectura a la que va dirigida el paquete. Existe una gran variedad de valores, pero nos interesan sobre todo \emph{i386} (la IA-32 habitual), \emph{source} (código fuente) y \emph{all} (código sin una arquitectura definida, como programas Java, o guiones de algún lenguaje interpretado como Perl o Python).

\item[\computeroutput{Depends}] \mbox{}
 Paquetes requeridos para que éste se instale y funcione correctamente. La variable \varname{\$\{shlib:Depends\}} incluye las dependencias deducidas de forma automática en cuanto a bibliotecas dinámicas se refiere. 

\item[\computeroutput{Description}] \mbox{}
Incluye una descripción corta de una sola línea y otra más larga de varias líneas del contenido del paquete. Al igual que siempre, su formato es muy rígido: toda línea de la descripción larga comienza por un espacio, y líneas vacías únicamente añaden un punto ('.'). El campo termina tras la primera línea sin dicho espacio inicial.

\end{description}

\note{ Mucho cuidado con los acentos y demás en el nombre del desarrollador del paquete y otros campos: podrían causar problemas en el interior de la jaula \application{chroot}, que sólo tiene soporte para los caracteres ASCII de 7 bits. }

\paragraph{copyright}

 Contiene la información relativa a la licencia del paquete y del programa original, junto con datos acerca de los autores originales, su copyright y de dónde descargamos el código fuente. 

 En este caso sólo tenemos que rellenar sin más los campos. No se fuerza ningún formato particular sobre el fichero. Es importante sustituir "Upstream Author(s)" por "Upstream Authors" y fijarnos en la información en \filename{docs/\-authors.txt} del código fuente, o los verificadores de paquetes que veremos después darán avisos al respecto. 

\paragraph{dirs}

 En este fichero listamos los directorios en que vamos a instalar algún fichero. Si no lo listamos aquí, dicho directorio no va a hallarse disponible durante la construcción del paquete, así que hay que tener cuidado. Las rutas deben de seguir el Filesystem Hierarchy Standard (FHS), disponible a través de la orden \command{man hier} desde cualquier terminal. 

 Algunas rutas importantes y sus contenidos son: 

\begin{description}
\item[\filename{/bin}] \mbox{}
Ejecutables usados en modo monousuario. Normalmente realizan tareas de mantenimiento a bajo nivel, entre otras cosas. Instalados a través de paquetes Debian.

\item[\filename{/boot}] \mbox{}
Configuración de GRUB, ficheros de imagen de los \emph{kernels} disponibles, etc.

\item[\filename{/dev}] \mbox{}
Árbol de directorios donde cada dispositivo conectado al sistema es un fichero.

\item[\filename{/etc}] \mbox{}
Ficheros de configuración global (para todos los usuarios).

\item[\filename{/home}] \mbox{}
Directorios de casa de cada usuario, con espacio para cada uno de ellos.

\item[\filename{/mnt}] \mbox{}
Dispositivos externos montados temporalmente: particiones de Windows, CD, DVD, pendrives, etc.

\item[\filename{/proc}] \mbox{}
Árbol de directorios con información del \emph{kernel} en cada fichero: procesos en ejecución, dispositivos disponibles, etc.

\item[\filename{/root}] \mbox{}
Directorio de casa del superusuario.

\item[\filename{/sbin}] \mbox{}
Ejecutables para uso del superusuario.

\item[\filename{/usr}] \mbox{}
Datos, programas y bibliotecas compartidos por todos los usuarios.

\item[\filename{/usr/bin}] \mbox{}
Ejecutables para todos los usuarios, instalados a través de paquetes Debian.

\item[\filename{/usr/lib}] \mbox{}
Bibliotecas para todos los usuarios, instalados a través de paquetes Debian.

\item[\filename{/usr/local}] \mbox{}
Similar a \filename{/usr}, pero para uso del administrador.

\item[\filename{/usr/share}] \mbox{}
Datos compartidos por todos los usuarios.

\item[\filename{/usr/share/man}] \mbox{}
 Páginas de \emph{man} disponibles. Toda página se halla dentro de una sección. En particular, la de \application{zsnes} estaría en la 1, tras ver las instrucciones disponibles a través de la orden \command{man man}. 

\end{description}

 Dado que tenemos que instalar el ejecutable para todos los usuarios y una página \emph{man}, nuestro fichero \filename{dirs} contendrá: 

\begin{alltt}
usr/bin
usr/share/man/man1	  
\end{alltt}

\note{ En este fichero, las rutas \emph{no} incluyen una barra inicial, como suelen hacer. Para ser más exactos, son rutas a crear dentro del área temporal de construcción del directorio \filename{debian/\-zsnes}, donde colocaremos todos los ficheros tal y como se descomprimirán después bajo el directorio raíz, \filename{/}. }

\paragraph{\filename{rules}}

 Aquí está el fichero más importante de todos. Es el que decide qué hay que hacer exactamente para compilar e instalar el paquete completo: documentación, binarios, guiones y ficheros de datos. 

 De todas formas, en términos generales, no es más que un \emph{makefile}, si bien uno que puede hacerse muy complejo: el objetivo \emph{build} compila, \emph{install} instala dentro del área de construcción del paquete, y \emph{clean} retira los ficheros generados durante la construcción. Esta última se halla bajo la ruta relativa \filename{debian/\-zsnes} respecto del directorio principal del paquete. 

 Dado que escribir una y otra vez un \emph{makefile} completo para muchas aplicaciones parecidas era una pérdida de tiempo, se han desarrollado diversos paquetes que factorizan cierta funcionalidad común, como instalar páginas \emph{man}, tipos MIME, entradas de menú, y cosas del estilo: son los guiones del paquete \filename{debhelper}. Prácticamente nadie hoy en día desarrolla sus paquetes sin estos guiones. 

 Algunos desarrolladores han decidido ir un paso más allá, y factorizar reglas para perfiles completos de aplicaciones. Así, si sabemos que se trata de una aplicación desarrollada a través de las autotools, sólo tendremos que aplicar dicho perfil, añadiendo las opciones oportunas que pasar a \filename{configure}, por ejemplo. Esto es el Common Debian Build System (CDBS)~\cite{cdbsdoc}, que usaremos en esta guía. Existen perfiles para aplicaciones Python, Perl, GNOME, KDE, Java (basadas en Ant), o incluso para aquellas con un simple \emph{makefile}. 

 Por supuesto, para paquetes complicados, este sistema se queda corto, pero son minoría comparados con los demás. Además, no es sólo cuestión de simplicidad: factorizando la mayor proporción posible de reglas, blindaremos nuestro paquete ante cambios en la política de Debian en el futuro. 

 De todas formas, en general, la comunidad de desarrolladores se halla muy dividida entre usar o no CDBS: aunque factoriza mucha complejidad, resulta difícil de comprender y aprovechar en casos difíciles, a menos que seamos capaces de leer complejos ficheros \emph{makefile} por nosotros mismos, dado que no existe mucha documentación detallada al respecto: para CDBS, el código es la mejor documentación. 

 Dado que resulta imposible entender bien CDBS si no se comprende antes el sistema tradicional, en esta sección explicaremos las dos alternativas. Comenzaremos por el sistema "tradicional" con los guiones de debhelper, y luego veremos cómo CDBS factoriza la mayor parte de estas reglas. 

\subparagraph{Reglas con \application{debhelper}}

 Partiendo del esqueleto que automáticamente nos ha creado \command{dh\_make}, lo retocamos para este paquete en particular. Vamos a ver qué tal ha quedado, y luego explicaremos qué partes exactamente hemos cambiado, y por qué: 

{ \lstset{language=make,basicstyle=\small}
\begin{lstlisting}[caption=Reglas de un paquete Debian creado con debhelper]
#!/usr/bin/make -f
# -*- makefile -*-

# This file was originally written by Joey Hess and Craig Small. As a
# special exception, when this file is copied by dh-make into a dh-make
# output file, you may use that output file without restriction.  This
# special exception was added by Craig Small in version 0.37 of dh-make.

# Uncomment this to turn on verbose mode.
#export DH_VERBOSE=1

# El código se halla en un subdirectorio, no en la raíz
SRCDIR = src
# Opciones a pasar a configure (--enable-release activa optimizaciones)
CONFIGURE_FLAGS = --disable-cpucheck --enable-release --with-x --with-opengl
# Opciones a usar en el compilador
CFLAGS = -Wall -g

ifneq (,$(findstring noopt,$(DEB_BUILD_OPTIONS)))
	CFLAGS += -O0
else
	CFLAGS += -O2
endif

configure: configure-stamp
configure-stamp:
	dh_testdir
	touch configure-stamp

build: build-stamp

build-stamp: configure-stamp 
	dh_testdir

	cd $(SRCDIR) && \
          force_arch=i586 ./configure $(CONFIGURE_FLAGS) --prefix=/usr
	$(MAKE) -C $(SRCDIR)

	touch $@

clean:
	dh_testdir
	dh_testroot
	rm -f build-stamp configure-stamp

	# Limpiamos también las herramientas internas usadas por ZSNES en su
	# compilación
	-$(MAKE) -C $(SRCDIR) clean tclean
	# Borramos los ficheros temporales generados por la compilación
	$(RM) $(SRCDIR)/tools/depbuild $(SRCDIR)/config.{log,status,h} $(SRCDIR)/Makefile

	dh_clean 

install: build
	dh_testdir
	dh_testroot
	dh_clean -k 
	dh_installdirs

	$(MAKE) -C $(SRCDIR) install DESTDIR=$(CURDIR)/debian/zsnes

# Build architecture-independent files here.
binary-indep: build install
# We have nothing to do by default.

# Build architecture-dependent files here.
binary-arch: build install
	dh_testdir
	dh_testroot
	dh_installchangelogs 
	dh_installdocs
	dh_installexamples
#	dh_install
#	dh_installmenu
#	dh_installdebconf	
#	dh_installlogrotate
#	dh_installemacsen
#	dh_installpam
#	dh_installmime
#	dh_python
#	dh_installinit
#	dh_installcron
#	dh_installinfo
	dh_installman $(SRCDIR)/linux/zsnes.1
	dh_link
	dh_strip
	dh_compress
	dh_fixperms
#	dh_perl
#	dh_makeshlibs
	dh_installdeb
	dh_shlibdeps
	dh_gencontrol
	dh_md5sums
	dh_builddeb

binary: binary-indep binary-arch
.PHONY: build clean binary-indep binary-arch binary install configure
\end{lstlisting}%$
}

 Aunque es bastante largo, conceptualmente es sencillo, gracias al uso de \application{debhelper}. Un par de cosas a destacar: 

\begin{enumerate}
\item  Dado que nuestro código fuente se halla bajo un subdirectorio y no en el directorio raíz del paquete, añadimos una variable \varname{SRCDIR}, cuyo valor tendremos en cuenta para realizar un cambio de directorio antes de cada orden de compilación. 

\item  Por otro lado, \varname{CURDIR} contiene la ruta del directorio raíz actual desde el cual se está construyendo el paquete. La ruta \filename{\$(CURDIR)/debian/\-zsnes} contiene un árbol de directorios que sigue el FHS, y se corresponde con los ficheros contenidos en el paquete \filename{zsnes}. 

\item  Bajo el objetivo de compilación \varname{build-stamp} añadimos las órdenes requeridas para compilar: invocamos al guión \filename{configure} con las opciones necesarias e iniciamos la compilación. La opción \option{-C} pasada a \command{make} hace el cambio de directorio antes de comenzar, justo como \command{cd} hace para las demás. Hay que hacerlo para cada orden y no al principio debido al hecho de que tras cada orden volvemos al directorio original, al restaurarse el estado anterior del shell. 

\item  Repetimos el cambio en la invocación a \command{make} para los otros objetivos \varname{clean} e \varname{install}. Puede verse cómo se pasa la variable de entorno \varname{DESTDIR} con la ruta al área de construcción para la instalación: evidentemente, el \emph{makefile} debe de estar hecho para tener esto en cuenta. Tenemos la suerte para este paquete de que ya sea así: de lo contrario, tendríamos que adaptar dicho fichero, ¡y posiblemente el resto del programa! 

\item  Por último, en el objetivo \varname{binary-arch} tenemos una serie de llamadas a distintos guiones de \application{debhelper}. Comentaremos y descomentaremos según nos haga falta: así, por ejemplo, un programa escrito en Perl no necesita \command{dh\_link} ni \command{dh\_strip}, al no generar ejecutables. 

 Hemos añadido un argumento a \command{dh\_installman} con la página \application{man} que queremos que se instale. Al igual que con todo lo demás, si no hubiera una, tendríamos que crearla nosotros. Lo más usual en este caso es escribir un fichero SGML o XML DocBook y transformarlo a \emph{nroff} (el formato de las páginas \application{man}) mediante \application{docbook-to-man} o una hoja de estilos XSLT, por ejemplo. Podríamos partir del ejemplo creado antes por \command{dh\_make}>, \filename{zsnes.sgml.ex}. 

\end{enumerate}

 Un detalle importante: la mayoría de los guiones suponen que los ficheros bajo nuestro directorio \filename{debian} siguen una serie de convenciones. Por ejemplo, \command{dh\_installdocs} supone que existe algún fichero \filename{debian/\-zsnes.docs} o \filename{debian/\-docs} que liste la documentación a instalar. En este caso, aprovechamos la documentación que ya trae ZSNES, con lo que tendríamos esto en \filename{debian/\-docs}: 

\begin{alltt}
docs/srcinfo.txt
docs/README.SVN
docs/opengl.txt
docs/stdards.txt
docs/authors.txt
docs/todo.txt
docs/install.txt
docs/thanks.txt
docs/support.txt
docs/README.LINUX
docs/readme.txt/about.txt
docs/readme.txt/faq.txt
docs/readme.txt/history.txt
docs/readme.txt/gui.txt
docs/readme.txt/advanced.txt
docs/readme.txt/index.txt
docs/readme.txt/games.txt
docs/readme.txt/netplay.txt
docs/readme.txt/readme.txt
docs/readme.txt/support.txt
docs/readme.htm/styles/release.css
docs/readme.htm/styles/print.css
docs/readme.htm/styles/jipcy.css
docs/readme.htm/styles/radio.css
docs/readme.htm/styles/corner.png
docs/readme.htm/styles/plaintxt.css
docs/readme.htm/styles/shared.css
docs/readme.htm/images/zsneslogo.png
docs/readme.htm/images/netplay.png
docs/readme.htm/images/quick.png
docs/readme.htm/images/saveslot.png
docs/readme.htm/images/cheat.png
docs/readme.htm/images/gui.png
docs/readme.htm/images/config.png
docs/readme.htm/images/game.png
docs/readme.htm/images/f1\_menu.png
docs/readme.htm/images/misc.png
docs/readme.htm/netplay.htm
docs/readme.htm/about.htm
docs/readme.htm/games.htm
docs/readme.htm/advanced.htm
docs/readme.htm/gui.htm
docs/readme.htm/support.htm
docs/readme.htm/readme.htm
docs/readme.htm/history.htm
docs/readme.htm/license.htm
docs/readme.htm/faq.htm
docs/readme.htm/index.htm
docs/readme.1st
\end{alltt}

\note{ Hemos usado ya otro fichero más del mismo estilo: \filename{dirs} es realmente el fichero que \command{dh\_installdirs} utiliza, por ejemplo. }

\subparagraph{Reglas con CDBS}

 Ahora que ya sabemos cuál es la estructura real de un fichero de reglas, lo reescribiremos empleando CDBS: 

\begin{lstlisting}[caption=Reglas de un paquete Debain creadas utilizando CDBS]
#!/usr/bin/make -f
# -*- makefile -*-

DEB_SRCDIR = src

include /usr/share/cdbs/1/rules/debhelper.mk
include /usr/share/cdbs/1/class/autotools.mk

DEB_CONFIGURE_SCRIPT_ENV   += force_arch=i586
DEB_CONFIGURE_EXTRA_FLAGS   = --disable-cpucheck --with-x \
  --enable-release --with-opengl
DEB_INSTALL_MANPAGES_zsnes += $(DEB_SRCDIR)/linux/zsnes.1
\end{lstlisting}%$

 Sorprendentemente, esto es todo: ocho líneas. Los dos \command{include} se ocupan de importar los conjuntos de reglas de apoyo para el uso interno de \application{debhelper} e implementar el soporte para el perfil de las autotools, respectivamente. 

 A continuación, pasamos las mismas opciones a \filename{configure} que antes: pedimos que compile para Pentium o superior, que emplee aceleración 3D y un interfaz gráfico, optimice algo más de lo normal (\verb#--enable-release#) y no intente autodetectar nuestra CPU. Finalmente, indicamos que instale la página man \filename{src/\-linux/\-zsnes.1} que incluye ZSNES. 

 Usaremos esta versión de \filename{debian/\-rules} para realizar el resto del documento, aprovechando algunas funcionalidades adicionales que aporta. Sin embargo, internamente, es exactamente lo mismo de antes. 

\subsubsection{Construcción preliminar}

 Con todo listo, ya podemos construir el paquete. Situándonos en el directorio principal del paquete, \filename{/tmp/\-packages/\-zsnes-1.510}, ejecutaremos: 

\begin{alltt}
dpkg-buildpackage -rfakeroot
\end{alltt}

 Tras un cierto tiempo, nos preguntará la contraseña de nuestra clave privada para firmar el paquete de forma automática. Poco después, tendremos en \filename{/tmp/\-packages} nuestra primera versión del paquete Debian, \filename{zsnes\_1.510-0ubuntu1\_i386.deb}, junto con un fichero \filename{.dsc} que describe el paquete fuente que también hemos construido, y un \filename{diff.gz} con las diferencias respecto a las fuentes originales. 

\subsubsection{Inyección en el repositorio}

 Con nuestra primera versión del paquete lista, sólo nos queda inyectar el paquete en el repositorio Subversion. Nos situaremos en \filename{\~{}/\-packages} y ejecutaremos: 

\begin{alltt}
svn-inject -c2 -o /tmp/packages/zsnes\_1.510-0ubuntu1.dsc \textbackslash{}
  file:///home/\emph{tunombredeusuario}/.svnDebian
\end{alltt}

 Tras un cierto tiempo, ya tendremos enviado al repositorio central nuestro paquete, y nuestra copia de trabajo habrá sido creada, con lo que no necesitaremos más \filename{/tmp/\-packages}. 

 La opción \option{-o} evita que se guarde el código fuente en el repositorio, usando únicamente archivos \filename{tar.gz} en el subdirectorio \filename{tarballs} del directorio principal del repositorio, que no se hallará bajo control de versiones. 

 El repositorio creado tiene la siguiente estructura: 

\begin{description}
\item[\filename{\~{}/packages/tarballs}] \mbox{}
 Contiene los ficheros \filename{tar.gz} con las fuentes originales de nuestros paquetes. 

\item[\filename{\~{}/packages/zsnes/build-area}] \mbox{}
 Se trata del directorio destino en el que se depositarán todos los paquetes y demás ficheros que vayamos produciendo. 

\item[\filename{\~{}/packages/zsnes/branches}] \mbox{}
 Almacena las distintas ramas de desarrollo. Normalmente contendría las distintas versiones del código original, pero al usar tarballs, es prácticamente inútil en nuestro caso. 

\item[\filename{\~{}/packages/zsnes/tags}] \mbox{}
 Permite asociar números de versión con determinadas revisiones del repositorio. Posteriormente veremos cómo se usa. 

\item[\filename{\~{}/packages/zsnes/trunk}] \mbox{}
 Aquí se almacena la versión actual del paquete. Sólo almacenamos el directorio \filename{debian}, para ahorrar la complejidad y tiempo de descarga necesario de otra forma. 

\end{description}

\subsection{Preparación de una primera versión}

\subsubsection{Construcción definitiva}

 Es el momento de reconstruir el paquete, pero esta vez haciendo uso de la jaula \application{chroot}, para asegurar que efectivamente hemos listado todas las dependencias correctamente. 

 Dado que la orden es bastante larga, lo mejor es añadir un alias a dicha orden, o mejor aún, declarar una función de \application{dash} (la versión reducida del shell \application{bash} de Ubuntu) que haga dicha tarea, en \filename{\~{}/.bashrc}. Añadiremos estas líneas: 

\begin{alltt}
function svn-b () {
  buildarea="`pwd`/../build-area";
  sudo cowbuilder --update
  svn-buildpackage  \textbackslash{}
    --svn-builder="pdebuild --auto-debsign --buildresult \${buildarea}" \textbackslash{}
    --svn-postbuild="rm \${buildarea}/*\_source.changes";
}

function svn-tag () {
  svn-buildpackage --svn-only-tag
}
\end{alltt}

 Nos situaremos en \filename{\~{}/packages/\-zsnes/\-trunk} y ejecutaremos: 

\begin{alltt}
svn-b
\end{alltt}

 Tras un tiempo prudencial, e introducir nuestras contraseñas de GPG y superusuario, tendremos una primera versión del paquete, comprobada dentro de una jaula \application{chroot}. 

\subsubsection{Verificación}

 Sin embargo, no basta con que se compile e instale correctamente. Además, el paquete debe de cumplir todas las políticas de Debian, como pertenecer a un determinado conjunto de secciones, tener todos sus ficheros de control bien escritos, respetar el estándar FHS que antes mencionamos, etc. 

 De hecho, si queremos que nos lleguen a aceptar cualquier paquete en un repositorio Debian oficial, como la sección \emph{universe} o \emph{multiverse} de Ubuntu, o la sección \emph{unstable} o \emph{testing} de Debian, lo mejor que podemos hacer para evitar hacer perder tiempo a nuestro supervisor o supervisores (que serán los que efectivamente suban al repositorio el paquete las primeras veces) es pasar antes nuestro paquete por los dos verificadores disponibles: Linda y Lintian, y retirar todos los avisos. 

\note{ Según parece, Linda, escrito en Python, es más reciente que Lintian, y también más rápido. Por otro lado, Lintian está escrito en Perl. Aparte de eso, no hay muchas diferencias: simplemente ejecutaremos ambos por seguridad, ya que tampoco supone un esfuerzo adicional considerable. }

 Lanzaremos los verificadores sobre el \filename{.deb}, que se hallará en \filename{\~{}/packages/\-zsnes/\-build-area}, pidiendo explicaciones de los avisos y errores con \option{-i}: 

\begin{alltt}
linda -i \~{}/packages/zsnes/build-area/zsnes\_1.510-0ubuntu1\_i386.deb
lintian -i \~{}/packages/zsnes/build-area/zsnes\_1.510-0ubuntu1\_i386.deb
\end{alltt}

 Según parece, no todo está bien en nuestro paquete: 

{ \small
\begin{alltt}
W: zsnes: extra-license-file usr/share/doc/zsnes/license.htm
N:
N:   All license information should be collected in the debian/copyright
N:   file. This usually makes it unnecessary for the package to install
N:   this information in other places as well.
N:   
N:   Refer to Policy Manual, section 12.5 for details.
N:
E: zsnes: FSSTND-dir-in-usr usr/man/
N:
N:   As of policy version 3.0.0.0, Debian no longer follows the FSSTND.
N:   
N:   Instead, the Filesystem Hierarchy Standard (FHS), version 2.3, is
N:   used. You can find it in /usr/share/doc/debian-policy/fhs/ .
N:
E: zsnes; Manual page zsnes.1.gz installed into /usr/man.
 The manual page shown is installed into the legacy location of
 /usr/man, where they should be installed into /usr/share/man.
E: zsnes; FSSTND directory /usr/man in /usr found.
 As of policy version 3.0.0.0, Debian no longer follows the FSSTND.
 Instead, the Filesystem Hierarchy Standard (FHS), version 2.1, is
 used. You can find it in /usr/share/doc/debian-policy/fhs/ .
E: zsnes; FSSTND directory /usr/man/man1 in /usr found.
W: zsnes; File /usr/share/doc/zsnes/license.htm is considered to be an
 extra license file.  The file shown above is considered to be another
 license file, where as the license for a package should be contained
 in the copyright file, which should be installed into
 /usr/share/doc/<pkg>.
\end{alltt}
}

 Analizando esta salida, vemos que hay cuatro problemas con nuestro paquete según Linda, y dos según Lintian. El primer problema es fácil de tratar: hemos incluido un fichero de licencia con la documentación (\varname{extra-license-file}), que no debería estar, ya que el archivo \filename{copyright} debería contener toda la información. Basta en este caso con retirar la línea problemática de \filename{debian/\-docs}. 

 El segundo problema es más complejo: el directorio \filename{/usr/\-man} no es parte del estándar actual, FHS, sino de uno más antiguo, el FSSTND (FileSystem Standard). En principio, nuestras reglas están bien escritas. Veamos si efectivamente nuestro paquete pone la página man en su sitio: 

\begin{alltt}
\prompt{\~{}/packages/zsnes/trunk\$ dpkg \textbackslash{}
  -c ../build-area/zsnes\_1.510-0ubuntu1\_i386.deb}     
\end{alltt}

 Sí que lo hace: \filename{/usr/\-share/\-man/\-man1/\-zsnes.1.gz} aparece como debería. Sin embargo, también aparece \filename{/usr/\-man/\-man1/\-zsnes.1.gz}. Así, hay algo fuera de nuestras reglas que está instalando en dicho sitio la página \application{man}. 

 Vamos a descomprimir en un directorio temporal el código fuente original, y echar un vistazo con la inestimable ayuda de \application{grep}, empleando la opción \option{-R} para hacer una búsqueda recursiva por el árbol de directorios y \option{-l} para solamente listar los ficheros con coincidencia y no el contenido que sigue el patrón: 

\begin{alltt}
cd /tmp
tar -xzf \~{}/packages/tarballs/zsnes\_1.510.orig.tar.gz
cd zsnes-1.510.orig
grep -Rl zsnes.1 *
\computeroutput{docs/srcinfo.txt
docs/readme.txt/readme.txt
docs/readme.htm/readme.htm
src/Makefile.in}
\end{alltt}

 Ya lo hemos encontrado: descartando los tres ficheros que forman parte de la documentación, sólo queda \filename{src/Makefile.in}. Tiene que ser el culpable, ya que este fichero es usado por el guión \filename{configure} para crear el \emph{makefile} con el que hacer la compilación e instalar el programa. 

 Veremos exactamente dónde está el problema, empleando la opción \option{-C} para ver un contexto de un determinado número de líneas alrededor de las apariciones: 

{ \small
\begin{alltt}
grep -C4 zsnes.1 src/Makefile.in
\computeroutput{install:
        @INSTALL@ -d -m 0755 \$(DESTDIR)/@prefix@/bin
        @INSTALL@ -m 0755 @ZSNESEXE@ \$(DESTDIR)/@prefix@/bin
        @INSTALL@ -d -m 0755 \$(DESTDIR)/@prefix@/man/man1
        @INSTALL@ -m 0644 linux/zsnes.1 \$(DESTDIR)/@prefix@/man/man1
uninstall:
        rm -f @prefix@/bin/\$(notdir @ZSNESEXE@) @prefix@/man/man1/zsnes.1

clean:
        rm -f \$(Z\_OBJS) \$(PSR) \$(PSR\_H) @ZSNESEXE@
tclean:
}
\end{alltt}
}

 Ya hemos encontrado las dos líneas problemáticas, al final del objetivo \varname{install}: crean el directorio e instalan la página \application{man}. Sólo hay que quitarlas. Sin embargo, hay un problema: no podemos tocar el código directamente, ya que no lo tenemos bajo control de versiones. Es más: no se considera buena práctica, ya que en futuras versiones los desarrolladores originales podrían arreglar ese problema, y se haría difícil ver quién ha hecho qué tras hacer unos cuantos cambios más. 

 Por eso, se considera buena práctica emplear un sistema de parches para hacer este tipo de modificaciones. Algunas alternativas~\cite{packagingpatching} incluyen el más antiguo, \application{dpatch}, el más reciente (y aparentemente superior, según los desarrolladores de SUSE) \application{quilt} y el que usaremos aquí, \application{simple-patchsys}, que como su nombre indica, está más inclinado hacia ser sencillo que ser potente. Sin embargo, nos basta para casos sencillos como éste. 

 Para usarlo, añadimos la línea que instala soporte para él en \filename{debian/\-rules}, justo después del primer \varname{include}: 

\begin{alltt}
include /usr/share/cdbs/1/rules/simple-patchsys.mk
\end{alltt}

 Pasaremos a crear el parche en sí. Para ello, tenemos que obtener el árbol de fuentes tal y como lo vería \filename{debuild} antes de compilar, y no como lo tenemos ahora. Para ello, usaremos \command{svn-buildpackage}, no sin antes enviar nuestros otros cambios al repositorio (de otra forma, no nos dejará seguir): 

{ \small
\begin{alltt}
\prompt{\~{}/packages/zsnes/trunk\$ svn commit -m \textbackslash{}
  "Integrado simple-patchsys del CDBS y corregido documentación"}
\computeroutput{Enviando       trunk/debian/docs
Enviando       trunk/debian/rules
Transmitiendo contenido de archivos ..
Commit de la revisión 6.}
\prompt{\~{}/packages/zsnes/trunk\$ svn-buildpackage --svn-export}
\computeroutput{buildArea: /home/antonio/packages/zsnes/build-area
[...]
I: mergeWithUpstream property set, looking for upstream source tarball...
[...]
Exportación completa.
rm -rf /home/antonio/packages/zsnes/build-area/tmp-0.00194501814349124
Build directory exported to /home/antonio/packages/zsnes/build-area/zsnes-1.510}
\end{alltt}
}

 Iremos al directorio exportado de construcción, que contendrá todos los ficheros necesarios, y generaremos el parche usando \command{cdbs-edit-patch}: 

\begin{alltt}
\prompt{\~{}/packages/zsnes/trunk\$ cd ../build-area/zsnes-1.510/}
\prompt{\~{}/packages/zsnes/build-area/zsnes-1.510\$ cdbs-edit-patch 01-man-fhs.patch}
\end{alltt}

 El programa nos indicará que nos hallamos ahora en un subshell, y que hagamos las modificaciones necesarias. Usando un editor cualquiera, retiraremos dichas líneas de \filename{src/\-Makefile.in}. Hecho esto, pulsaremos \texttt{CTRL + D} o introduciremos la orden \command{exit} para salir del subshell y dejar que cree el parche \filename{debian/\-patches/\-01-man-fhs.patch} con los cambios que hemos hecho. 

 Sólo hemos de colocar ahora el parche en el sitio correcto, y guardar los cambios en el repositorio: 

\begin{alltt}
cd \~{}/packages/zsnes/trunk
cp -r ../build-area/zsnes-1.510/debian/patches debian
svn add debian/patches
svn commit -m "Arreglado problema con la página man en /usr/man"
\end{alltt}

 Ahora reconstruiremos el paquete: 

\begin{alltt}
svn-b
\end{alltt}

 Ya, por fin, Lintian y Linda no dan ningún aviso. Probaremos a instalar el paquete, y ver qué tal funciona: 

\begin{alltt}
sudo dpkg -i ../build-area/zsnes\_1.510-0ubuntu1\_i386.deb
\end{alltt}

 Tras probar un poco el emulador con alguna ROM libremente disponible, como las de PDRoms (\url{http://www.pdroms.com}), decidimos que el paquete está en condiciones de ser usado. Usaremos la otra función que definimos antes para marcar esta versión del paquete, copiando los contenidos de \filename{trunk} en un nuevo subdirectorio de \filename{tags} cuyo nombre será la versión actual del paquete, para después confirmar los cambios que se habrán realizado automáticamente en \filename{debian/changelog}, en preparación para la siguiente versión de nuestro paquete: 

\begin{alltt}
svn-tag
svn commit -m "Copiado a tags versión 1.510-0ubuntu1 del paquete"
\end{alltt}

\subsubsection{Envío al repositorio Debian}

 Después de haber verificado nuestro paquete y haber marcado la versión en el repositorio Subversion, es momento de enviarlo al repositorio Debian, para que nuestros usuarios puedan acceder fácilmente a él. Añadiremos tanto el paquete fuente como el paquete compilado: 

\begin{alltt}
sudo -E reprepro includedeb gutsy \textbackslash{}
 \~{}/packages/zsnes/build-area/zsnes\_1.510-0ubuntu1\_i386.deb
sudo -E reprepro -S main -P low includedsc gutsy \textbackslash{}
 \~{}/packages/zsnes/build-area/zsnes\_1.510-0ubuntu1.dsc
\end{alltt}

 Deberíamos probar el paquete justo como un usuario normal lo haría. Pero, primero, tenemos que desinstalar la versión que instalamos antes a partir de un fichero: 

\begin{alltt}
sudo aptitude remove zsnes
sudo aptitude update
sudo aptitude install zsnes
\end{alltt}

\subsection{Actualización del paquete a una nueva versión del programa}

 Cada cierto tiempo, deberemos de actualizar nuestro repositorio con los cambios realizados en el código. Para ello, disponemos de la orden \command{svn-upgrade}, a la que le pasaremos un fichero \filename{tar.gz} con el nuevo código fuente del paquete. 

 Ahora probaremos a actualizar nuestro paquete con el código correspondiente a la última versión en el repositorio Subversion del equipo de ZSNES. Primero, prepararemos el tarball con el código original. Descargamos el código fuente, y lo exportamos a otro directorio, para retirar los ficheros usados por \application{Subversion}: 

\begin{alltt}
svn checkout https://svn.bountysource.com/zsnes/trunk zsnes-svn
svn export zsnes-svn zsnes-1.510.SVN5215
\end{alltt}

 He decidido usar el esquema \varname{1.510.SVN5215} para indicar que se trata de la revisión 5215 del repositorio. De esta forma, si sale una nueva versión oficial, o si empleo una revisión más reciente del repositorio Subversion, como \varname{1.520} o \varname{1.510.SVN5216}, éstas serán considerada más recientes, y la actualización se podrá hacer de forma correcta. Podemos comprobar que es efectivamente así mediante la siguiente orden: 

\begin{alltt}
dpkg --compare-versions "1.510-0ubuntu1" gt "1.510.SVN5215-0ubuntu1" \&\& \textbackslash{}
  echo "1.510-0ubuntu1 mayor que 1.510.SVN5215-0ubuntu1" || \textbackslash{}
  echo "1.510-0ubuntu1 menor que 1.510.SVN5215-0ubuntu1"
\end{alltt}

 Ahora que ya tenemos el código, inspeccionaremos un momento para ver si todos los ficheros importantes se hallan en su sitio. Normalmente, no se suelen almacenar ficheros generados automáticamente en el repositorio, así que pueden que falten algunas cosas importantes. Mirando en \filename{src}, vemos que falta el guión \filename{configure} que necesitamos para compilar. Lo generaremos ejecutando las siguientes órdenes bajo \filename{src}, el mismo directorio donde se halla su fichero fuente, \filename{configure.in}: 

\begin{alltt}
aclocal
autoconf
\end{alltt}

 También faltan los directorios \filename{docs/\-readme.txt} y \filename{docs/\-readme.htm}, que añadiremos en su sitio. Con esto tenemos los ficheros fuente listos. Vamos a crear el tarball que necesitamos: 

\begin{alltt}
\prompt{/tmp\$ tar -czf zsnes-1.510.SVN5215.tar.gz zsnes-1.510.SVN5215}
\end{alltt}

 El siguiente paso es añadir dicho código a nuestra área de trabajo, e indicar que vamos comenzar a empaquetar una nueva versión del programa. Volvemos al directorio con la versión actual de nuestro paquete y ejecutamos: 

\begin{alltt}
\prompt{\~{}/packages/zsnes/trunk\$ svn-upgrade /tmp/zsnes-1.510.SVN5215.tar.gz}
\end{alltt}

 Se harán los cambios necesarios en \filename{debian/\-changelog} y el resto del repositorio. Cambiaremos el número de versión del paquete a \varname{0ubuntu1} y confirmamos dichos cambios antes de volver a reconstruir el paquete: 

\begin{alltt}
\prompt{\~{}/packages/zsnes/trunk\$ svn commit -m \textbackslash{}
  "Actualizado con rev 5215 upstream"}
\prompt{\~{}/packages/zsnes/trunk\$ svn-b}
\end{alltt}

 Sin embargo, la reconstrucción falla. Buscando entre los distintos mensajes, podemos ver una línea del estilo: 

\begin{alltt}
\computeroutput{Trying patch 01-man-fhs.patch at level 1 ... 0 ... 2 ... failed.}
\end{alltt}

 En resumen: el parche que antes hicimos para corregir el problema de \filename{Makefile.in} no se ha podido aplicar. Tras inspeccionar sus contenidos, vemos que efectivamente \filename{Makefile.in} ha cambiado demasiado: 

\begin{alltt}
install:
	@INSTALL@ -d -m 0755 \$(DESTDIR)/@bindir@
	@INSTALL@ -m 0755 @ZSNESEXE@ \$(DESTDIR)/@bindir@
	@INSTALL@ -d -m 0755 \$(DESTDIR)/@mandir@/man1
	@INSTALL@ -m 0644 linux/zsnes.1 \$(DESTDIR)/@mandir@/man1
\end{alltt}

 Vaya, parece que ellos mismos han corregido ya el problema que teníamos antes. Ésta es precisamente la razón por la que usamos un parche, en vez de cambiar directamente el código. Sólo tenemos que eliminar el parche, confirmar los cambios y reconstruir: 

\begin{alltt}
\prompt{\~{}/packages/zsnes/trunk\$ svn rm debian/patches}
\computeroutput{D  debian/patches/01-man-fhs.patch}
\prompt{\~{}/packages/zsnes/trunk\$ svn commit -m \textbackslash{}
  "01-man-fhs.patch: Retirado (corregido por upstream)"}
\computeroutput{Deleting       zsnes/trunk/debian/patches/01-man-fhs.patch
Transmitting file data .
Committed revision 11.}
\prompt{\~{}/packages/zsnes/trunk\$ svn-b}
\end{alltt}

 Esta vez ya no da el fallo del parche, pero indica que faltan las bibliotecas de desarrollo de Qt para la nueva interfaz. Añadiremos la dependencia en \filename{libqt4-dev} al fichero \filename{control} y volveremos a intentarlo tras confirmar otra vez nuestros cambios. 

 Esta vez falla diciendo que no puede construir el fichero \filename{ui\_zsnes.h}, que hace falta para compilar. Probaremos a compilar sobre el directorio \filename{/tmp/zsnes-1.510.SVN5215/\-src} tras instalar las dependencias en nuestro propio sistema: 

\begin{alltt}
./configure
make
\end{alltt}

 Da el mismo problema, así que no es culpa de nuestro paquete. Vamos a mirar con \application{grep}, a ver qué puede ser: 

\begin{alltt}
\prompt{grep -R ui\_zsnes.h *}
\computeroutput{makefile.ms:\${GUI\_D}/gui.cpp: \${GUI\_D}/ui\_zsnes.h
src/gui/gui.h:\#include "ui\_zsnes.h"
Makefile.in:GUI\_QO=\$(GUI\_D)/moc\_gui.cpp \$(GUI\_D)/ui\_zsnes.h
Makefile:GUI\_QO=\$(GUI\_D)/moc\_gui.cpp \$(GUI\_D)/ui\_zsnes.h
makefile.dep:gui/gui.o: gui/gui.cpp gui/gui.h ui\_zsnes.h
}
\end{alltt}

 Si nos fijamos, se puede ver que en \filename{makefile.dep} la ruta no se corresponde con la de las anteriores entradas, por lo que seguramente ahí estará el fallo. Esta vez buscamos por este fichero: 

{ \small
\begin{alltt}
\prompt{grep -R makefile.dep *}
\computeroutput{src/configure:touch -t 198001010000 makefile.dep
src/Makefile.in:main: makefile.dep \$(Z\_QOBJS) \$(Z\_OBJS)
src/Makefile.in:include makefile.dep
src/Makefile.in:makefile.dep: \$(TOOL\_D)/depbuild Makefile
src/Makefile.in: \$(TOOL\_D)/depbuild @CC@ "@CFLAGS@" @NASMPATH@
"@NFLAGS@" \$(Z\_OBJS) > makefile.dep
src/Makefile.in: rm -f makefile.dep \$(Z\_OBJS) \$(Z\_QOBJS) \$(PSR)
\$(PSR\_H) @ZSNESEXE@
src/Makefile:main: makefile.dep \$(Z\_QOBJS) \$(Z\_OBJS)
src/Makefile:include makefile.dep
src/Makefile:makefile.dep: \$(TOOL\_D)/depbuild Makefile
src/Makefile: \$(TOOL\_D)/depbuild gcc " -pipe -I. -I/usr/local/include
-I/usr/include -D\_\_UNIXSDL\_\_ -I/usr/include/SDL -D\_GNU\_SOURCE=1
-D\_REENTRANT -D\_\_OPENGL\_\_ -DNO\_DEBUGGER -DNDEBUG -march=athlon-xp -O2
-fomit-frame-pointer -s -DQT\_SHARED -I/usr/include/qt4
-I/usr/include/qt4/QtCore -I/usr/include/qt4/QtGui " nasm "
-w-orphan-labels -D\_\_UNIXSDL\_\_ -f elf -DELF -D\_\_OPENGL\_\_ -DNO\_DEBUGGER
-O1" \$(Z\_OBJS) > makefile.dep
src/Makefile: rm -f makefile.dep \$(Z\_OBJS) \$(Z\_QOBJS) \$(PSR) \$(PSR\_H)
zsnes
src/autom4te.cache/output.0:touch -t 198001010000 makefile.dep
src/autom4te.cache/output.1:touch -t 198001010000 makefile.dep
src/configure.in:touch -t 198001010000 makefile.dep
}
\end{alltt}
}

 Puede verse que en \filename{src/Makefile} es donde se crea a través de una herramienta propia de los desarrolladores de ZSNES, que obtiene automáticamente las dependencias. Recordando la lista anterior de ficheros que mencionaban a \filename{ui\_zsnes.h}, se nos viene a la cabeza \filename{gui/\-gui.h}. Vamos a probar a cambiar la ruta de inclusión a \filename{gui/\-ui\_zsnes.h}: 

\begin{alltt}
cd \~{}/packages/zsnes/trunk
svn-buildpackage --svn-export
cd ../build-area/zsnes-1.510.SVN5215
cdbs-edit-patch 02-fix-depbuild.patch
\end{alltt}

 Hacemos el cambio antes mencionado con el editor \application{vim} y salimos del shell, tras lo cual reintentaremos la construcción del paquete: 

\begin{alltt}
vim src/gui/gui.h
exit
\end{alltt}

 Ahora la reconstrucción ha tenido éxito. Ya sólo tendríamos que seguir los mismos pasos anteriores de verificación, validación manual, marcado en el repositorio (tras retirar el aviso <<NOT RELEASED YET>> añadido automáticamente a \filename{debian/changelog}, claro), y envío. Cualquiera de nuestros usuarios será notificado eventualmente de la actualización y podrá instalar la versión más reciente del paquete. 

 Una última nota: si se quiere, se puede integrar la verificación y publicación en la función \command{svn-b} antes definida, cambiando las líneas correspondientes en \filename{\~{}/.bashrc} por: 

\lstset{language=bash}
\begin{lstlisting}[basicstyle=\small,caption=Funciones Bash de ayuda para construcción de paquetes]
function svn-b () {
  buildarea="`pwd`/../build-area";
  rutapaquete="${buildarea}/\${package}_\${debian_version}*.deb";
  rutadsc="${buildarea}/\${package}_\${debian_version}*.dsc";
  rutarepo="/var/packages/ubuntu";
  sudo cowbuilder --update
  svn-buildpackage  \
    --svn-builder="pdebuild --auto-debsign --buildresult ${buildarea}" \
    --svn-postbuild="rm ${buildarea}/*_source.changes; \
            lintian -i ${rutapaquete}; linda -i ${rutapaquete}; \
            cd ${rutarepo} && \
            sudo -E reprepro remove gutsy \${package} && \
            sudo -E reprepro includedeb gutsy ${rutapaquete} && \
            sudo -E reprepro -S main -P low includedsc gutsy ${rutadsc}";
}
function svn-tag () {
  svn-buildpackage --svn-only-tag
}
\end{lstlisting}%$

\section{Otros aspectos de interés}

\subsection{Integración de repositorio propio con la jaula \application{chroot}}

 En este tutorial no hará falta, pero sí es posible que nos haga falta para casos más complejos. Cuando haya interdependencias entre varios paquetes que deseemos crear, tendremos que añadir nuestro repositorio (que estará alojado en su propio servidor web) a la lista de los repositorios de la jaula \application{chroot}. 

 Para ello, nos introduciremos en la jaula e importaremos la firma digital de nuestros paquetes: 

\begin{alltt}
sudo cowbuilder --login --save-after-login
wget http://\emph{direccion.delservidor.org}/claveDebian.asc
apt-key add claveDebian.asc
\end{alltt}

 Con esto, la jaula ya confiará en nuestros paquetes. Tenemos que añadir entonces la siguiente línea a \filename{/etc/apt/sources.list}, usando el editor \application{vim}: 

\begin{alltt}
deb http://\emph{direccion.delservidor.org}/ubuntu gutsy main
\end{alltt}

 Actualizamos la lista de paquetes: 

\begin{alltt}
aptitude update
\end{alltt}

 Hemos terminado, así que sólo queda salir del shell de la jaula: 

\begin{alltt}
exit
\end{alltt}

\subsection{Sincronización de un repositorio en Internet con un repositorio local}

 En muchos casos no dispondremos de los medios necesarios como para dejar nuestro ordenador como servidor web al exterior para que sirva nuestros paquetes. En estos casos, podemos subir nuestros ficheros \filename{.deb} a una forja o algo del estilo y dejar que los usuarios se los bajen. 

 Pero, ¿y si son muchos paquetes, o si queremos mantener actualizados a los usuarios? Lo mejor sería replicar completo el repositorio en un servidor conectado permantentmente a Internet. La mejor opción es, por tanto, obtener espacio de alojamiento con acceso mediante SFTP o FTP. 

 Una vez lo hayamos conseguido, podríamos subir el árbol completo de directorios de nuestra máquina al servidor remoto, pero hacer esto una y otra vez tardaría demasiado. La mejor opción es hacer un \emph{mirror inverso} a través de la herramienta \application{lftp}, que nos pedirá la contraseña antes de conectarse: 

\begin{alltt}
lftp -d -e "mirror -venR \emph{ruta local} \textbackslash{}
                         \emph{ruta remota} \textbackslash{}
                         \emph{dirección del servidor}"
\end{alltt}

 Si queremos que no nos pregunte una y otra vez la contraseña, siempre podemos añadir líneas como éstas a \filename{\~{}/.netrc}, cuidando de que sólo sea legible por nosotros: 

\begin{alltt}
machine \emph{mi.servidor.com}
login \emph{minombredeusuario}
password \emph{micontraseña}
\end{alltt}

\subsection{Adaptación de aplicaciones Java}

 La principal diferencia al crear un paquete Java es, sin duda, el hecho de que, a pesar de tener que compilar, el paquete en sí no tiene ninguna arquitectura definida. Ello debería verse reflejado en \filename{debian/control}. 

 Además, debería tener en \varname{Build-Depends} algún compilador de Java, y en \varname{Depends} el paquete virtual \filename{java2-runtime}, además de una alternativa concreta, como la de Sun, \filename{sun-java6-jre}, o preferiblemente la basada en OpenJDK, \filename{icedtea-java7-jre}, usando el operador lógico OR (\varname{|}). Los paquetes virtuales no añaden ninguna funcionalidad: se limitan a hacer cosas como ayudarnos a instalar varios paquetes de una sola vez (usándolos en su campo \varname{Depends}), o permitiéndonos usar un paquete cualquiera que nos provea de una cierta funcionalidad. 

 Así, si curioseamos en el paquete \filename{sun-java6-jre}, veremos que tiene a dicho paquete virtual en el campo \varname{Provides} (<<Proporciona>>): 

\begin{alltt}
\prompt{\$ aptitude show sun-java6-jre}
\computeroutput{Paquete: sun-java6-jre
[...]
Proporciona: java-virtual-machine, java1-runtime, java2-runtime
[...]}
\end{alltt}

 Si usamos el compilador de Sun en Build-Depends (paquete \filename{sun-java6-jdk}), habremos de cambiar nuestro \filename{.pbuilderrc} para que use un interfaz distinto de entrada, que nos deje aceptar los términos de la DLJ de Sun. Añadimos estas líneas: 

\begin{alltt}
\# Para poder aceptar la licencia DLJ
export DEBIAN\_FRONTEND="readline" 
\end{alltt}

 Además de eso, tendremos como de costumbre que adaptar nuestro programa Java para que sea fácilmente compilable de forma automática, y para que se integre bien dentro del sistema. Un problema es que no deberíamos escribir rutas absolutas en el código Java, o si no perderemos toda la transportabilidad que deseábamos en un primer momento. La forma más fácil de implementar lo que deseamos es simplemente utilizar variables de entorno o propiedades del sistema. 

 A veces no nos servirá cualquier JRE de los disponibles para ejecutar nuestro programa, y tendremos que prescindir de usar \filename{java2-runtime}. Es el caso usual de las aplicaciones basadas en Swing: el JRE por defecto en Gutsy, GCJ, sólo implementa completamente SWT. Tendremos que hacer que el sistema instale y active otro JRE. 

 Para poder establecerlas de forma separada del programa Java antes de lanzarlo, lo que necesitamos es un guión de shell, que será el que instalaremos en \filename{/usr/bin}. El fichero \filename{.jar}, siguiendo la política de Debian, debe ir en \filename{/usr/share/java}. 

 El que sea fácilmente compilable de forma automática depende de qué sistema hayamos estado usando. Si nos hemos basado en un IDE, seguramente aquí tengamos problemas. Lo que deberíamos hacer es reescribir la fase de compilación usando un guión para \application{Apache Ant}. Esto, de paso, nos permitirá aprovechar el perfil de CDBS, simplificando bastante nuestra tarea. \application{Ant} es efectivamente un sustituto del \application{GNU Make} escrito en Java, para aplicaciones Java. Utiliza ficheros muy del estilo de los \emph{makefile}, sólo que escritos en XML. 

 Con todo esto, aún hay un par de complicaciones adicionales. Normalmente, los ficheros fuente Java se hallan escritos en UTF-8. Sin embargo, la jaula \application{chroot} que antes hicimos en~\ref{paqueteslimpios} (página~\pageref{paqueteslimpios}) no tiene en principio una localización compatible instalada. Vamos a tener que entrar en la jaula e instalar los paquetes necesarios, comprobando la situación que aquí describimos con \command{locale} (nos mostrará que usamos la localización estándar <<C>>): 

\begin{alltt}
sudo cowbuilder --login --save-after-login
aptitude install language-pack-es
exit
\end{alltt}

 Ahora, lo que hemos de hacer es asegurarnos que cuando llamemos a \application{Ant}, lo hagamos estableciendo una localización con UTF-8: 

\begin{alltt}
LANG=es\_ES.UTF-8 ant compile
\end{alltt}

 Deberíamos además invocar las pruebas de unidad sobre el código, para asegurarnos de que el código usado en el paquete no presente regresiones. Además de añadir el paquete \filename{junit} a \varname{Build-Depends}, tenemos que tener en cuenta que si en alguna prueba de unidad usamos un componente Swing, aunque no se muestre nada en pantalla, requeriremos un servidor X, o de lo contrario la prueba fallará. Dado que ejecutar un servidor X completo en una jaula \application{chroot} es un gasto inútil de recursos, vamos a usar un falso servidor X, que añadiremos también a \varname{Build-Depends}: \filename{xvfb}. Para tener disponible el servidor X durante una orden, únicamente ponemos \command{xvfb-run} antes de ella. Combinándolo con lo de las localizaciones, tendremos que ejecutar una orden como ésta: 

\begin{alltt}
LANG=es\_ES.UTF-8 xvfb-run ant (objetivo-compilación)
\end{alltt}

\subsection{Actualización del escritorio}

 Antes conseguimos crear un paquete con un binario, junto con su página \emph{man}. Sin embargo, para que realmente consideremos al paquete completo, deberíamos integrarlo con el gestor de escritorio del usuario. Veremos cómo añadir el acceso directo al menú, y cómo asociar los ficheros ROM de Super Nintendo al emulador ZSNES. 

 Esta tarea se ha hecho en los últimos años mucho más sencilla gracias a las especificaciones ofrecidas por el grupo FreeDesktop.org~\cite{fdgspecs}, que hace de centro de reunión para diversos proyectos relacionados con entornos gráficos. Así, KDE y GNOME emplean el mismo formato para describir las entradas de su menú, por ejemplo. 

\subsubsection{Accesos directos e iconos}

 Normalmente, existen dos sitios del menú de aplicaciones donde podemos instalar un acceso directo a nuestra aplicación: el menú Debian, y el propio menú normal de aplicaciones. Por completitud, trataremos ambos, aunque hoy en día el menú Debian no se usa demasiado. Además, no aparece por omisión en un sistema Ubuntu: hay que instalar el paquete \filename{menu} para poder usarlo. 

 Para que se añada una entrada al menú Debian, hemos de asegurarnos de que la línea con \command{dh\_installmenu} se halle descomentada en \filename{debian/rules}. Dado que nuestro paquete se llama \filename{zsnes}, crearemos un fichero \filename{debian/zsnes.menu} con este contenido: 

\begin{alltt}
?package(zsnes):needs="X11" section="Games/Arcade" \textbackslash{}
  title="ZSNES" command="/usr/bin/zsnes" \textbackslash{}
  icon="/usr/share/pixmaps/zsnes.xpm"
\end{alltt}

 El significado de los campos es el siguiente: 

\begin{description}
\item[\varname{needs="X11"}] \mbox{}
Indica que el programa tiene una interfaz gráfica, requiriendo un servidor X.

\item[\varname{section="Games/Arcade"}] \mbox{}
Especifica dónde debería situarse el acceso directo. Las secciones se hallan prefijadas por la política de empaquetado de Debian.

\item[\varname{title="ZSNES"}] \mbox{}
Éste es el texto que se mostrará en la entrada del menú.

\item[\varname{command="/usr/bin/zsnes"}] \mbox{}
Ésta es la orden exacta que será ejecutada.

\item[\varname{icon="/usr/share/pixmaps/zsnes.xpm"}] \mbox{}
Tal y como indica el grupo FreeDesktop.org, hemos instalado el icono en formato XPM y en la ruta \filename{/usr/\-share/\-pixmaps}. Para convertir dicha imagen, podemos usar simplemente \application{Gimp}, o el programa \command{convert} del paquete \filename{imagemagick}, de esta forma:

\begin{alltt}
convert zsnes.png zsnes.xpm
\end{alltt}

\end{description}

 Ahora hemos de centrarnos en que aparezca en los menús de KDE y GNOME. Para que sea así, hemos de crear otro fichero más, \filename{debian/\-zsnes.desktop}, con el siguiente contenido: 

\begin{alltt}
[Desktop Entry]
Name=ZSNES
Type=Application
Comment=SNES (Super Nintendo) emulator that uses x86 assembly
Comment[es]=Emulador de SNES que emplea código ensamblador de x86
Exec=/usr/bin/zsnes  \%f
Icon=zsnes.png
MimeType=application/x-snes-rom;
Categories=Game;Emulator;
\end{alltt}

 Dicho fichero ha de hallarse codificado tal y como indica el campo \varname{Encoding}: en UTF-8. Además de indicar el nombre y el tipo de la aplicación, podemos especificar una descripción más larga. Adelanto un detalle para realizar la asociación de ficheros: el campo \varname{Exec}, que contiene la orden a ejecutar, permite especificar sustituciones como \option{ \%f}, que será sustituido por el primer fichero con el que se active el acceso directo. Si hay varios, se ejecutará el emulador tantas veces como ficheros haya, con un fichero distinto cada vez. 

 En \varname{Categories} incluimos las categorías a las que pertenece esta aplicación: son más bien anotaciones semánticas que una descripción jerárquica de dónde debería colocarse exactamente. Debe de haber al menos una de las categorías principales según~\cite{fdmenu} (o si no no aparecerá en el menú), y pueden haber categorías adicionales para dar más información. 

 Los campos con texto descriptivo como \varname{Name} y \varname{Comment} se pueden personalizar según el idioma añadiendo al nombre de campo, entre corchetes, un identificador de idioma de ISO 639. He incluido un ejemplo para \varname{Comment}. El campo \varname{Icon} no requiere la ruta, ya que el directorio \filename{/usr/\-share/\-pixmaps} es uno de los consultados de forma automática. 

 Otro detalle también importante para crear la asociación de fichero es especificar el tipo MIME de los ficheros que esta aplicación abre. Dado que no existe un tipo estándar MIME para ROM de Super Nintendo, definimos uno nosotros, cuidando de poner el prefijo \varname{x-} en la segunda mitad, indicando que no es estándar. 

Validaremos el fichero mediante \command{desktop-file-validate}, sin más problemas. En caso contrario habría que hacer las correcciones oportunas.

 Ahora que tenemos los dos ficheros con la información necesaria, vamos a definir las acciones requeridas para instalarlos debidamente. En primer lugar, la llamada que necesitamos hacer a \command{dh\_installmenu} ya la hace CDBS por nosotros, con lo que ya tendríamos la parte de instalar la entrada en el menú Debian. Aún tenemos que instalar el fichero \filename{.desktop}, el icono, y añadir el icono al caché de GNOME, para mejorar la eficiencia. Añadimos estas líneas a \filename{debian/\-rules}: 

\begin{alltt}
install/zsnes::
  dh\_install -m 0644 \$(CURDIR)/debian/zsnes.desktop  \textbackslash{}
                     /usr/share/applications
  dh\_install -m 0644 \$(CURDIR)/debian/zsnes.xpm      \textbackslash{}
                     /usr/share/pixmaps
  dh\_desktop
  dh\_iconcache
\end{alltt}

 Cuando reconstruyamos el paquete, veremos que nos aparecerán dos ficheros nuevos en el directorio \filename{debian}: \filename{zsnes.postrm.debhelper} y \filename{zsnes.postinst.debhelper}. Estos ficheros son guiones Bash generados automáticamente que se ejecutan después de la desinstalación e instalación. También hay guiones equivalentes para antes de la instalación y la desinstalación, llamados \filename{preinst} y \filename{prerm}, respectivamente. El sufijo \filename{.debhelper} indica al mecanismo de construcción de paquetes que debe concatenar su contenido con el que pudieran tener los ficheros sin tal sufijo, como \filename{zsnes.postrm}, que nosotros mismos habríamos escrito manualmente. 

 En particular, \command{dh\_desktop} ha añadido una llamada a \filename{update-desktop-database}, y \command{dh\_installmenu} otra llamada a \filename{update-menu}. Con esto, nos aseguramos de que el menú sea actualizado debidamente y que el entorno de escritorio sepa que nuestro programa está disponible para abrir cualquier ROM de Super Nintendo. 

 Posteriormente, tras instalar el paquete, dichos guiones son guardados en \filename{/var/\-lib/\-dpkg/\-info}. Si alguna vez nos equivocamos al escribir alguno de ellos, es posible que no podamos ni terminar de desinstalar ni de instalar el paquete. Podemos forzar a que su ejecución termine con éxito añadiendo al inicio del guión en dicho directorio la línea: 

\begin{alltt}
exit 0
\end{alltt}

Así ya podremos retirar el paquete e instalar una versión con dicho fallo corregido.

\subsubsection{Actualización de los tipos MIME}

 Ya nuestro sistema sabe que puede abrir ROM de Super Nintendo con ZSNES. Tenemos el acceso directo, y el icono. Sólo falta decirle al sistema cómo identificar una ROM de Super Nintendo. 

 En general, hay dos formas de identificar el tipo de un fichero: a través de una secuencia binaria específica en la cabecera (como en el caso de las imágenes en formato BMP, que incluyen siempre los caracteres <<BM>> al inicio del fichero), conocida como \emph{magic cookie}, o a través de la extensión. 

 Aunque usar el contenido del fichero es mucho más robusto, no conozco realmente si siguen algún formato específico (probablemente no), así que nos limitaremos a la extensión, algo mucho más sencillo. En particular, nos centraremos en las dos más populares: \filename{.sfc} y \filename{.smc}. 

 Añadimos a nuestro paquete el fichero XML \filename{debian/\-zsnes.sharedmimeinfo} siguiente: 

\begin{alltt}
<?xml version="1.0" encoding="utf-8"?>
<mime-info 
  xmlns="http://www.freedesktop.org/standards/shared-mime-info">
   <mime-type type="application/x-snes-rom">
     <comment>SNES ROM</comment>
     <comment xml:lang="es">ROM de SNES</comment>
     <glob pattern="*.sfc"/>
     <glob pattern="*.smc"/>
   </mime-type>
</mime-info>
\end{alltt}

 Tras la declaración XML, incluimos el elemento raíz \varname{mime-info}, con la declaración del espacio de nombres para documentos de tipos MIME de FreeDesktop.org. Ahora tendríamos una serie de tipos MIME con \filename{mime-type}, dando una línea descriptiva en posiblemente varios idiomas (de nuevo usando códigos de ISO 639), y posteriomente especificando patrones con los que identificar los ficheros que pertenecen a dicho tipo: \varname{glob} usa un simple patrón de ficheros del shell (no se trata de una expresión regular, como podemos ver), y \varname{magic} nos permitiría identificar por contenido. 

 Ahora deberíamos asegurarnos de que la línea que llama a \command{dh\_installmime} se halle descomentada, si usáramos sólo \application{debhelper}, pero con CDBS no hay que hacer nada más. La llamada a \command{update-mime-database} será añadida automáticamente a los guiones de postinstalación y postdesinstalación por el guión anterior, y el fichero será instalado en su lugar correcto, \filename{/usr/\-share/\-mime/\-packages}. Podemos comprobar, tras instalar el paquete, que la asociación se ha realizado bien inspeccionando \filename{/usr/\-share/\-mime/\-globs}, que debería contener las líneas: 

\begin{alltt}
application/x-snes-rom:*.sfc
application/x-snes-rom:*.smc
\end{alltt}

\subsection{Generación automática de paquetes}

\subsubsection{Módulos Perl}

 El guión \command{dh-make-perl} nos permite crear rápidamente versiones preliminares de paquetes Debian para módulos Perl del CPAN (Comprehensive Perl Archive Network)~\cite{cpan}. De esta forma, podemos integrar todos los módulos necesarios para nuestra aplicación Perl en paquetes, y que así el usuario pueda instalarla justo como cualquier otra aplicación. 

 Así, si queremos empaquetar el módulo \filename{XML::Writer} del CPAN, escribiremos: 

\begin{alltt}
dh-make-perl --cpan XML::Writer
\end{alltt}

 Es posible que tengamos que hacer algunos retoques a \filename{debian/\-control} o a \filename{debian/\-rules} si el sistema de compilación del paquete no es compatible con el habitual (MakeMaker), o si tiene dependencias que no puedan detectarse automáticamente. Por lo general, no habrá mucho que hacer: el CPAN impone ciertas cosas que hacen que la tarea sea bastante más sencilla que con otros programas. 

 Una nota: el servicio CPAN tiene enlaces a otro servicio muy útil que indica exactamente las dependencias de un paquete Perl cualquiera de forma recursiva, y nos indica cuáles módulos se hallan preconfigurados (y no requieren de un paquete por lo tanto) y cuáles no. 

 También es útil instalar el paquete \application{apt-file}, que es capaz de encontrar el paquete que contiene un determinado fichero, de tal forma que pueda ser añadido automáticamente a las dependencias del paquete generado. Es importante actualizar el caché cada cierto tiempo de esta forma: 

\begin{alltt}
sudo apt-file update
\end{alltt}

\subsubsection{Adaptación de guiones de instalación}

 Un caso muy común es cuando nosotros mismos tenemos que compilar alguna aplicación, porque no dispongamos de un paquete apropiado. ¿Deberíamos directamente instalarla, y perder así las ventajas de una desinstalación limpia y segura, y la posibilidad de posteriormente actualizar a una versión posterior si finalmente aparece un paquete? 

 No hace realmente falta: \application{checkinstall}~\cite{checkinstall}, cuyo paquete del mismo nombre tendremos que instalar, se ocupa de invocar \command{make install}, seguir todo el rastro de la instalación, y crear un rudimentario paquete Debian (también hay soporte para paquetes Slackware y RPM) a partir de él. Realiza la instalación automáticamente, y nos deja un paquete en el mismo directorio, que podemos pasar a cualquiera para que también lo instale. Por supuesto, el paquete no podremos subirlo a ningún repositorio serio: no tiene ninguna información de dependencias, por ejemplo, ni se halla firmado. 

 Si por ejemplo estamos compilando un programa basado en las \application{autotools} (unión de \application{autoconf}, \application{automake} y a veces \application{libtool}), sólo habría que cambiar el último paso: 

\begin{alltt}
./configure --prefix=/usr
make
sudo checkinstall
\end{alltt}

\subsection{Otros formatos de paquete}

\subsubsection{Comparativa con otros formatos}

 Los paquetes Debian son sólo un tipo más de paquete que podemos encontrar. Otras distribuciones han desarrollado sus propios sistemas de empaquetado, con mayor o menor funcionalidad, y con mayor o menor éxito. En esta guía, mencionaremos los otros tres formatos más populares: RPM, Portage y Slackware. 

\paragraph{RPM}

 El formato RPM (RedHat Package Manager) es el empleado actualmente en las distribuciones SUSE y Fedora, entre otras, y es originario de la ahora desaparecida RedHat Linux. Tiene funcionalidad en el mismo nivel de los paquetes Debian, con guiones de pre/postinstalación y desinstalación, y metadatos, como por ejemplo las dependencias. Sin embargo, esta información de dependencias es menos rica que la de los paquetes Debian: sólo existe un tipo de dependencia, mientras que en los paquetes Debian tenemos recomendaciones (paquetes que casi siempre necesitaremos junto con el actual) y sugerencias (paquetes que mejorarían la funcionalidad del actual). Además, en los paquetes Debian podemos especificar alternativas en las dependencias, y usar paquetes virtuales, que indiquen la disponibilidad de una cierta funcionalidad, como <<navegador web>> o <<entorno de ejecución Java>>, más que un software determinado. 

 Por otro lado, a diferencia de los paquetes Debian, incorpora guiones de verificación de la correcta instalación de un paquete, y disparadores al cambiar el estado de algún otro paquete. También incluye la capacidad de definir dependencias sobre ficheros, aunque a muchos no les parece realmente útil. 

 El principal problema de este formato era la falta de resolución automática de dependencias en la herramienta de gestión de paquetes \command{rpm} estándar: ésta simplemente informaba de las dependencias directas que no habían sido cumplidas, obligándonos a reintentar el proceso bajando un paquete tras otro hasta finalmente conseguir instalar el paquete deseado. Sin embargo, ya existen herramientas que añaden esta resolución de forma transparente, como \command{yum} de Fedora, \application{YaST} de SUSE, o \command{urpmi} de Mandriva. 

 Gracias a esas herramientas, hoy en día el problema es distinto, y se basa más en la forma y contenido de los paquetes en sí: no existe una política estricta y estándar de empaquetado como la que tienen los paquetes Debian~\cite{debianpolicy}, ni herramientas de validación. Por ello, un RPM no suele funcionar bien fuera de la versión específica de la distribución en que se desarrolló. Además, no hay tanto software empaquetado en formato RPM como lo hay en formato Debian, ni de forma tan accesible. 

\paragraph{Portage}

 El sistema Portage de Gentoo es una versión para Linux del sistema \emph{ports} de FreeBSD: realmente, un paquete de Gentoo se halla formado por un fichero \filename{ebuild}, que contiene las instrucciones de cómo obtener, compilar, instalar y configurar el software. 

 Normalmente, tras compilar el paquete, obtenemos también un paquete parecido a los que estamos acostumbrados a ver. Así, si tenemos varias máquinas con la misma versión de Gentoo, no tendremos que compilar en cada máquina. De la misma forma, existen también paquetes binarios precompilados si los necesitamos. De esa forma evitaremos tener que recompilar muchas aplicaciones grandes, como OpenOffice o KDE, por ejemplo. 

 Los ficheros \filename{ebuild} incluyen información de dependencias, y la herramienta usada para la instalación, \command{emerge}, las sigue de forma transitiva. También disponemos de paquetes virtuales, con la misma semántica que en Debian. El único problema se halla en las dependencias inversas: a la hora de retirar un paquete, Portage no comprueba si estamos rompiendo algún otro paquete. Existen herramientas como \command{revdep-rebuild} que hacen esta comprobación por nosotros, pero no se hallan integradas con el proceso de desinstalación. 

 Otro problemas incluyen el tener que realizar mantenimiento constante sobre los ficheros de configuración de los paquetes que actualicemos, o el ciclo de desarrollo más corto de los paquetes Gentoo frente a los de Debian. Aunque normalmente tendremos software mucho más reciente, no estará tan probado como lo podría estar un paquete Debian, y podemos llevarnos más de un disgusto. 

 Por lo demás, se trata de un sistema muy completo, con la capacidad de actualizar todo nuestro sistema comprobando nuestras dependencias de forma transitiva automáticamente, entre otras cosas. Obtenemos las actualizaciones sincronizando de forma periódica nuestro árbol de ficheros \filename{ebuild} con un directorio remoto mediante \command{rsync}. 

\paragraph{Slackware}

 El formato \filename{tgz}, de Slackware: es únicamente un \filename{tar.gz} que será descomprimido directamente a \filename{/}, para después ejecutar un guión de postinstalación. Se corresponde con la filosofía de dicha distribución: el usuario es el que sabe qué hay que hacer. 

 No incorpora metadatos de ningún tipo, ni control de dependencias. Es posiblemente el formato más sencillo de empaquetado que podríamos imaginarnos. 

\subsubsection{Conversión desde paquetes Debian}

 Puede que queramos que usuarios de SUSE, Slackware o Fedora, por ejemplo, empleen nuestro programa. Quizás no tengamos tiempo como para mantener un paquete para todos y cada uno de los otros muchos formatos disponibles. 

 La herramienta \application{alien} (como siempre, antes deberemos instalar su paquete) nos deja convertir entre paquetes Debian, Slackware, Solaris, RPM, LSB y Stampede. Es bastante experimental, y los paquetes generados no tendrán la misma calidad que uno hecho a mano, pero puede ser útil en muchos casos. 

 Así, para convertir cualquier paquete a formato Debian, usaremos: 

\begin{alltt}
alien \emph{(ruta al paquete)}
\end{alltt}

 Por otro lado, si queremos crear un paquete RPM a partir de un paquete Debian, podríamos usar, como en el caso de ZSNES: 

\begin{verbatim}
alien --to-rpm \
  \~{}/packages/build-area/zsnes\_1.510.SVN5113-0ubuntu1\_i386.deb
\end{verbatim}

 Sólo hemos de tener cuidado de que la conversión se haya hecho lo bastante bien: por ejemplo, los guiones de preinstalación, postinstalación y demás no se convierten bien al formato RPM. Posiblemente tendremos que editar los ficheros generados para asegurarnos de que funcionen bien. 
  
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../memoria"
%%% End: 
