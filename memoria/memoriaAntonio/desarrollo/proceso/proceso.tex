%%
%% proceso.tex
%% 
%% Made by Antonio GarcÃ­a
%% Login   <antonio@localhost>
%% 
%% $Id: proceso.tex 605 2008-06-21 17:57:21Z antonio $
%%

Se ha seguido la metodología \ac{XP} en el desarrollo de este
proyecto. Fue creada por Kent Beck, Ward Cunningham y Ron Jeffries durante
el desarrollo del \ac{C3}, un sistema unificado de gestión de nóminas.

La parte ``Extreme'' de \ac{XP} consiste en llevar prácticas conocidas
y recomendadas de la ingeniería de software a su máxima expresión. Por
ejemplo, si las pruebas son buenas, entonces todo el código debería
tener pruebas, y además éstas deberían estar automatizadas y
ejecutarse continuamente.

\subsection{Origen}

Su popularización se dio a través de la participación conjunta de
estos tres autores, con intervenciones del resto de la comunidad, en
la web~\cite{xpwiki}, fundada en 1995. 

En 1999 su popularidad se vio aumentada en gran medida tras la
publicación de la primera edición de ``Extreme Programming
Explained''. 

Para este proyecto, se siguió la segunda edición~\cite{xpexplained},
publicada en 2004, que en respuesta a las críticas recibidas introdujo
importantes cambios y reorganizaciones, como la sustitución de las 12
prácticas por un núcleo de prácticas obligatorias apoyado por una
serie de prácticas opcionales.

Ya se mencionó anteriormente en \S\ref{sec:porcentajes} otra obra
relacionada con \ac{XP} (\cite{planxp}).

\subsection{Características}
\label{sec:xp_caract}
\index{métodos ágiles}
\index{XP|see{Extreme Programming}}
\index{Extreme Programming}

\ac{XP} es una metodología ágil de desarrollo de software, aplicable
por lo general a proyectos de pequeño y medio tamaño, en un equipo de
hasta 12 personas.

En los métodos ágiles, se descarta todo documento o procedimiento
innecesario para el proyecto, permitiendo al equipo avanzar
rápidamente concentrándose en lo importante y sin perder tiempo en
formalismos.

En \ac{XP}, los detalles se comunican en conversaciones directas entre
las partes implicadas (incluyendo al cliente), aclarando confusiones y
dudas en el momento.  Así, \ac{XP} se dirige más a las personas que al
proceso, y más a la obtención de software útil que al seguimiento de
un proceso rígido y burocrático.

En cada iteración, se entrega una versión funcional del software que
el cliente puede probar para ampliar la información disponible en la
siguiente iteración.

Una idea que se suele tener respecto a \ac{XP} (por aquello de que es
``Extreme'') es que no se realiza documentación en absoluto, sea lo
que sea. El requisito de documentación externa al proyecto es muy
común, por ejemplo, y debe ser atendido. Ron Jeffries trata de
corregir éste y otros malentendidos en~\cite{xpmisconceptions}.

A diferencia de otras metodologías, donde el cliente es una entidad
externa al proyecto con el que se sólo se comunica el analista, en
\ac{XP} es una parte integral del equipo. Se ocupa de formular los
requisitos a nivel conceptual, darles su prioridad, y resolver dudas
que pueda tener el resto del equipo.

\ac{XP} nos recuerda así que el software existe para dar un valor
añadido al cliente, y no por sí mismo. Así, las decisiones acerca de
la funcionalidad deseada son del cliente, y las decisiones técnicas y
el calendario lo establecen los desarrolladores.

\subsubsection{Valores}
\label{sec:xp_valores}

Aquí se describen algunos de los valores que todo proyecto basado en
\ac{XP} debe tener en mente:

\begin{description}
\item[Simplicidad] 
  \index{valor XP!simplicidad}
  \index{simplicidad|see{valor XP!simplicidad}}

  La solución más sencilla suele ser la mejor. Esto no quiere decir
  que se use la primera solución que se nos ocurra. La solución
  escogida debe:
  \begin{itemize}
  \item Hacer todo lo esperado.
  \item No contener ninguna duplicación.
  \item Pasar todas las pruebas.
  \item Tener el mínimo número de elementos.
  \end{itemize}

  Lo que este valor intenta evitar es el diseño excesivo al tratar de
  resolver problemas aún no planteados. Dicho trabajo podría ser
  inútil o incluso contraproducente si el cliente cambiara de opinión
  acerca del resto de los requisitos aún no implementados. No se trata
  de anticipar el cambio, sino de adaptarse a él.

\item[Comunicación] 
  \index{valor XP!comunicación}
  \index{comunicación|see{valor XP!comunicación}}

  Consiste en la comunicación transparente y sin obstáculos entre
  todas las partes del equipo, incluido el cliente. La falta de
  comunicación induce a problemas o malentendidos que podrían haberse
  resuelto fácilmente de lo contrario.

\item[Aprendizaje] 
  \index{valor XP!aprendizaje}
  \index{aprendizaje|see{valor XP!aprendizaje}}

  Más que intentar capturar toda la información de una vez, un
  proyecto basado en \ac{XP} debe de concentrarse en el día a día,
  aprendiendo paso a paso qué es lo que se espera exactamente del
  programa, dado que ni siquiera el cliente lo sabe con seguridad.

  Dicha información puede venir de muchas fuentes: del cliente, de la
  experiencia propia, de las pruebas automatizadas, etc.  Otras veces,
  cuando no se sabe cómo atacar un problema, se puede aprender
  realizando experimentos y evaluando varias alternativas, para así
  poder elegir la mejor y evitar discusiones improductivas.

\end{description}


\subsubsection{Principios}
\label{sec:xp_principios}

Para seguir esos valores, se proponen una serie de principios, que se
concretan a través de una serie de prácticas recomendadas. Dichos
principios incluyen por ejemplo:
\begin{description}
\item[Flujo] 
  \index{principio XP!flujo}
  \index{flujo|see{principio XP!flujo}}

  Se deben de realizar constantemente todas las actividades del
  desarrollo de software: análisis, diseño, implementación,
  integración y pruebas.

  Esto evita la acumulación de riesgos a la hora de integrar y
  validar, realizando entregas frecuentes con pequeños riesgos e
  incrementos de funcionalidad, más que una única entrega con alto
  riesgo y toda la funcionalidad.

\item[Margen] 
  \index{principio XP!margen}
  \index{margen|see{principio XP!margen}}

  En todo plan, se debe de tener margen para en el caso de no tener
  suficiente tiempo poder dejar algunas historias para posteriores
  versiones.

  Éste ha sido el caso de sobre todo \postprocesador{}, que sólo
  procesa un subconjunto limitado de la salida de \ac{ACL2}, pero es
  completamente funcional dentro de dicho subconjunto, y mantiene un
  diseño que facilitará futuras ampliaciones.

\item[Calidad] 
  \index{principio XP!calidad}
  \index{calidad|see{principio XP!calidad}}

  La calidad no es algo opcional, y disminuir el nivel aceptado de
  calidad no garantiza una reducción del tiempo de desarrollo. De
  hecho, suele aumentarlo.

  El control del tiempo de un proyecto no debe ser así basado en su
  calidad, sino sobre todo en su alcance. Es mejor hacer una sola cosa
  bien que varias mal.

\item[Centrado en las personas] 
  \index{principio XP!centrado en las personas}
  \index{centrado en las personas|see{principio XP!centrado en las personas}}

  Son las personas las que realizan el software, no la metodología de
  desarrollo.

  Una metodología de desarrollo de software ha de tener en cuenta las
  necesidades y limitaciones de las personas. En una labor
  fundamentalmente creativa como es el desarrollo de software, se
  necesita que el equipo trabaje a su máximo rendimiento de forma
  sostenible.  

\end{description}

\subsubsection{Prácticas}
\label{sec:xp_practicas}

Las prácticas de \ac{XP} se dividen en dos partes: un núcleo de reglas
que todo proyecto \ac{XP} debe cumplir, y otras prácticas recomendadas
pero no obligatorias, que suelen tener como requisito el cumplimiento
de todas las reglas principales.

En el caso de este Proyecto, hay tareas que sencillamente no se han
podido seguir, como ``Programación en Parejas'', o ``Trabajar Juntos''
(reunir al equipo de desarrollo en un lugar), por razones obvias.

Algunas de las prácticas seguidas son:
\begin{description}
\item[Historias] 
  \index{práctica XP!historia de usuario}
  \index{historia de usuario|see{prácticas XP!historia de usuario}}

  Las historias de usuario son algo completamente distinto de los
  casos de uso. Describen una funcionalidad o propiedad deseada del
  sistema, en palabras del usuario y no del desarrollador. Mediante
  ellos se pueden expresar todo tipo de requisitos, no sólo los
  funcionales, y en ellos se basan las pruebas de aceptación.

  Por otro lado, un caso de uso representa de forma abstracta la
  interacción entre el sistema y los demás entes externos, incluyendo
  el actor principal y los secundarios.

  \ac{XP} no prohíbe el empleo de los casos de uso. De hecho, se
  pueden usar en combinación, sirviendo el caso de uso como una
  generalización de una o varias historias de usuario particulares.

  Así, puede verse que una historia de usuario es algo mucho más
  concreto, generalmente pequeño y fácilmente estimable, mientras que
  un caso de uso se podría ver como una clase de interacciones
  concretas que el sistema ha de posibilitar. Ambos describen el
  \emph{qué}, pero lo hacen bajo distintos enfoques.

  El equipo de desarrollo puede realizar estimaciones del esfuerzo que
  requeriría una historia y presentárselas al cliente, dándole más
  información para decidir qué historias quiere implementadas en cada
  iteración. Puede que se decida posponer una historia, o dividirla en
  varias.

  En mi caso, los ``clientes'' han sido mis directores de proyecto,
  especialistas en \ac{ACL2}, y por lo tanto usuarios potenciales del
  proyecto.

\item[Integración Continua] 
  \index{práctica XP!integración continua}
  \index{integración continua|see{práctica XP!integración continua}}

  La prueba e integración de los cambios se realiza de forma continua
  y a pequeños pasos. Esto se sigue del hecho de que corregir los
  fallos introducidos en el software es tanto más complicado cuanto
  más amplios sean los cambios.

\item[Ciclo Semanal] 
  \index{práctica XP!ciclo semanal}
  \index{ciclo semanal|see{práctica XP!ciclo semanal}}

  La planificación se ha realizado en ciclos cortos, de duración
  aproximada de una semana, y se ha mantenido una comunicación semana
  a semana con los ``clientes'', en este caso los directores del
  proyecto.

\item[Compilación en 10 Minutos] 
  \index{práctica XP!compilación en 10 minutos}
  \index{compilación en 10 minutos|see{práctica XP!compilación en 10 minutos}}

  Aunque para un proyecto de este tamaño no sea una tarea difícil de
  realizar, se puede considerar un requisito para ``Integración
  Continua''.

  La idea consiste en mantener siempre el tiempo de compilación y
  ejecución de todas las pruebas automáticas pertinentes por debajo de
  10 minutos, para poder realizar integración continua del código de
  todo el equipo y evitar tanto problemas de integración de última
  hora como esperas innecesarias.

\item[Programación Basada en Pruebas] 
  \index{práctica XP!programación basada en pruebas}
  \index{programación basada en pruebas|see{práctica XP!programación basada en pruebas}}

  Los componentes más importantes de \visor{} han sido desarrollados
  de esta forma usando JUnit, en cuyo desarrollo participó el propio
  Kent Beck. Existen otras herramientas para realizar pruebas de
  unidad: la obra~\cite{javaxpcookbook} describe las más conocidas en
  Java.

  En este método de programación, se escribe primero una prueba que
  demuestra que la funcionalidad deseada está implementada. Una vez
  está escrita la prueba, se comprueba que ésta falle, tras añadir el
  código estrictamente necesario para que todo compile.

  Es entonces cuando se añade el código necesario a la implementación
  para hacer que se superen dicha prueba y las anteriores.

  Además de garantizar mayor corrección, el uso de este estilo obliga
  al desarrollador a estructurar su código para que sea fácil de
  probar, haciéndolo modular y cohesivo. Refactorizaciones posteriores
  en el diseño pueden garantizar inmediatamente la misma funcionalidad
  que la versión anterior.

  En el caso de \postprocesador{}, se ha seguido un proceso similar:
  \begin{enumerate}
  \item Se decide el enunciado Lisp a tratar junto con su salida de
    \ac{ACL2}.
  \item Se define a grandes rasgos el resultado \ac{XML} deseado a
    partir de la salida de \ac{ACL2}.
  \item Se lanza el post-procesador sobre el enunciado y la salida.
    \label{item:lanzar_pproc}

    \begin{enumerate}[\ref{item:lanzar_pproc}a.]
    \item Se obtiene el resultado deseado: se continúa con el proceso.
    \item No se obtiene el resultado deseado: se refina el
      post-procesador y se vuelve al paso \ref{item:lanzar_pproc}.
    \end{enumerate}

  \item Se marca el resultado \ac{XML} como válido.

  \item Se lanzan las pruebas de regresión, comparando automáticamente
    cada resultado \ac{XML} obtenido por la versión actual del
    post-procesador con las últimas versiones validadas:
    \label{item:lanzar_regresion}

    \begin{enumerate}[\ref{item:lanzar_regresion}a.]
    \item No hay diferencias: se escoge otro enunciado y su salida y
      se repite el proceso.
    \item Hay diferencias: si constituyen regresiones, se corrigen y
      se vuelve al paso \ref{item:lanzar_regresion}. En caso de falso
      positivo, se refina la comparación lo estrictamente necesario
      para evitarlo si se puede, o de lo contrario se marca la salida
      \ac{XML} como válida y se reemplaza a la anterior.
    \end{enumerate}
  \end{enumerate}

  El proceso no difiere mucho de la programación basada en pruebas
  usual: se definen los resultados deseados y entonces se añade la
  funcionalidad necesaria. La diferencia radica en que la prueba es de
  todo el post-procesador, y no de una clase o método, como las
  usuales pruebas de unidad.

  El proceso completo se halla dirigido a través de los mecanismos
  usuales de pruebas de unidad empleados para cualquier módulo del
  \ac{CPAN}, como \modulo{Test::More} o \modulo{Test::Simple}.

  \yaxml{} hace algo muy parecido a \postprocesador{}: toda mejora se
  realiza tras añadir un nuevo documento \ac{YAML} 1.1 o \ac{JSON} al
  conjunto de casos de prueba. Cada caso de prueba es ejecutado de la
  siguiente forma:

  \begin{enumerate}
  \item El documento origen se convierte a \ac{XML} mediante \yaxml{}.
  \item El documento \ac{XML} resultante se convierte de nuevo a
    \ac{YAML} mediante una versión mejorada de la hoja \ac{XSLT} de
    \ac{YAXML}.
  \item Se deserializa el documento original y el documento final y se
    comprueban que las dos estructuras de datos resultantes son
    iguales elemento a elemento.
  \end{enumerate}

\item[Diseño incremental] 
  \index{práctica XP!diseño incremental}
  \index{diseño incremental|see{práctica XP!diseño incremental}}

  Las metodologías tradicionales, siguiendo el modelo de ciclo de vida
  de cascada, intentaban realizar el análisis y diseño de antemano,
  siguiendo el modelo de la ingeniería tradicional.

  Se realizaba la analogía entre la construcción de una casa y la de
  un proyecto software: una vez estaban implantados los cimientos,
  cambiar la estructura del edificio era varios órdenes de magnitud
  más caro.

  \ac{XP} afirma lo contrario: el diseño del programa no es algo que
  se haga una sola vez y quede fijo por el resto de la vida del
  programa.  Se debe refinar continuamente en función de las
  necesidades del momento.

  Para evitar el aumento del coste de las modificaciones, se dispone
  de otras prácticas además de ésta, como el uso de pruebas
  automáticas, la compartición de código, la programación en parejas y
  la comunicación fluida con el resto del equipo.

  Así evitamos tanto el diseño excesivo, que supone una pérdida de
  tiempo, como la falta de diseño (conocida como el anti-patrón \emph{Bola
  de Barro}~\cite{perloowiki}), que dificulta la introducción de
  cambios.

\end{description}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../memoria"
%%% End: 
