%
% Capa de filtrado: YAXML::Reverse
% Copyright (C) 2008 Antonio García Domínguez
% $Id$

\subsubsection{Descripción general}
\label{sec:descripcion_general}

Este conversor implementa la correspondencia \ac{XML} $\rightarrow$
\ac{YAML} conocida como \ac{YAXML}~\cite{YAXML} en sentido inverso,
con dos objetivos en general:

\begin{itemize}
\item En primer lugar, para permitir a \visor{} abrir cualquier
  documento basado en el metalenguaje \ac{YAML}, o su subconjunto
  (desde \ac{YAML} 1.1) \ac{JSON}. Ello permitirá tratar una familia
  completa nueva de formatos.

\item En segundo lugar, para todos aquellos que necesiten aplicar
  alguna herramienta a sus documentos que no esté disponible para
  \ac{YAML}, como transformaciones definidas de forma funcional
  mediante \ac{XSLT}.
\end{itemize}

El proceso es relativamente sencillo:

\begin{enumerate}
\item Se analiza el documento origen \ac{YAML}, deserializándose a una
  estructura de datos Perl. Este primer paso se consigue mediante el
  módulo Perl \modulo{YAML::XS}, un \emph{binding} que permite
  aprovechar la funcionalidad de la biblioteca \verb#libyaml#
  (disponible en \url{http://pyyaml.org/wiki/LibYAML}), y analizar
  documentos \ac{YAML} 1.1 y \ac{JSON}. Existen una serie de
  restricciones, que veremos posteriormente en el
  apartado~\ref{sec:limitaciones} de la
  página~\pageref{sec:limitaciones}.

\item Se representa dicha estructura como un árbol \ac{XML}, con una
  versión mejorada del formato sugerido por \ac{YAXML} para tratar
  ciertos casos especiales.
\end{enumerate}

Sin embargo, hay una serie de detalles de interés en la inversión de
\ac{YAXML} que consideramos merece la pena mencionar. También se han
encontrado algunas limitaciones debidas en primer lugar al módulo
\modulo{YAML::XS}, y en última instancia al propio lenguaje Perl, pero
se estima que tendrán realmente poco impacto en su uso.

\subsubsection{Regeneración de anclas y alias en el fichero \acs{XML}}
\label{sec:anclas_alias_xml}

Hay una diferencia muy importante en los modelos de información
comúnmente usados en \ac{YAML} y \ac{XML}: el modelo de información de
presentación de \ac{YAML}, tal y como se comentó
en~\S\ref{sec:modinf_yaml} (página~\pageref{sec:modinf_yaml}), utiliza
grafos dirigidos con raíz, y el modelo \ac{DOM} comúnmente usado en \ac{XML}
emplea árboles. Esto implica dos problemas, fundamentalmente:

\begin{itemize}
\item Un primer problema, de menor importancia, es el hecho de que si
  un nodo del grafo tiene varios arcos entrantes, tendrá que ser
  repetido varias veces en el árbol final. Este problema se agrava
  cuando el nodo a repetir no es un nodo hoja, sino un nodo raíz de un
  subgrafo: tendremos que repetir el subgrafo completo. De todas
  formas, este problema es más una cuestión de eficiencia, y en
  ciertos casos se podría incluso aceptar el coste adicional.

\item El problema mayor es que en los grafos de \ac{YAML}, se admiten
  ciclos: no existe forma de representar directamente estas
  estructuras cíclicas en un árbol \ac{XML}.
\end{itemize}

\index{YAML!ancla}
\index{YAML!alias}

La forma en que \ac{YAXML} resuelve estos problemas es utilizando no
el modelo de información de representación, sino el modelo de
información de serialización, que sí está basado en árboles. En dicho
modelo, se definen los conceptos de \emph{ancla} y de \emph{alias},
pudiendo así establecer enlaces entre los nodos del árbol, y resolver
los dos problemas anteriores. En \ac{YAXML}, se representan como
atributos de un elemento sin contenido (como \verb#<a/>#). Pueden
compararse los resultados para un caso sencillo en la
figura~\ref{fig:grafos_mediante_arboles} de la
página~\pageref{fig:grafos_mediante_arboles}.

Existe un problema, sin embargo: utilizando \modulo{YAML::XS}, lo que
obtenemos es el grafo final. Para reconstruir el árbol con anclas y
alias a partir del grafo, hemos de distinguir qué elementos del grafo
constituyen anclas y qué elementos constituyen alias a esas
anclas. Podemos aprovechar el hecho de que la estructura creada por
\modulo{YAML::XS} se basa en referencias a direcciones de memoria con
vectores asociativos, listas y objetos: si en dos o más puntos del
árbol aparecen referencias a la misma dirección de memoria, sabremos
que la primera aparición será el ancla, y todas las demás serán sus
alias.

El mayor problema es que no sabremos si un nodo constituye un ancla
hasta que sea usado como tal por primera vez en cualquier otro punto
del documento. Por ello, tendremos entonces que dividir la generación
de la salida en dos pasos:

\begin{enumerate}
\item En una primera pasada, se recopila en un vector asociativo qué
  referencias constituyen anclas, junto con su posición en orden de
  uso, a partir de la cual se generará el identificador final.

\item En la segunda pasada, se genera el código \ac{XML}, cuidando de
  generar los atributos \verb#anchor# y \verb#alias# en los nodos
  apropiados.
\end{enumerate}

\begin{figure}
  \centering
  \mbox{\subfigure[Grafo original]{\includegraphics[width=.3\textwidth]{desarrollo/diseno/grafos_yaml_original}}\quad
    \subfigure[Árbol sin enlaces]{\includegraphics[width=.3\textwidth]{desarrollo/diseno/grafos_yaml_arbolsinenlaces}}\quad
    \subfigure[Árbol con enlaces]{\includegraphics[width=.3\textwidth]{desarrollo/diseno/grafos_yaml_arbolconenlaces}}\quad
  }
  \caption{Representación de grafos mediante árboles XML}
  \label{fig:grafos_mediante_arboles}
\end{figure}

\subsubsection{Pruebas de unidad automáticas basadas en equivalencia}
\label{sec:yaxml_equivalencia}

\index{oráculo}

Un problema fundamental en la realización de pruebas de software es la
elaboración de los \emph{oráculos}~\cite{Baresi:Oracles} necesarios
para comprobar si el comportamiento del software es el
esperado. Existe una gran variedad de tipos, según la naturaleza del
software bajo prueba.

En lo que respecta a \yaxml{}, necesitamos un oráculo que nos diga si
un documento \ac{YAML} ha sido convertido a \ac{XML} sin pérdidas ni
cambios en su información a nivel semántico. Lo ideal es que sea lo
más automático posible: no es factible programar un caso de prueba
para cada entrada. No podemos hacer comparaciones directas del texto,
pues un documento \ac{YAML} puede ser escrito en muchos estilos
distintos, y los documentos \ac{XML} también disponen de ciertos
mecanismos para el manejo del espaciado, por ejemplo.

Una posibilidad es generar un analizador de los documentos \ac{XML}
obtenidos, que construyera representaciones del estilo de las de
\modulo{YAML::XS} y las comparara con los grafos originales. Hay una
forma de conseguir algo similar con un esfuerzo mucho menor: podemos
aprovechar el hecho de que combinando \ac{YAXML} y \yaxml{} cerramos
el ciclo en torno a \ac{YAML} y \ac{XML}: podemos así hacer una
transformación \ac{YAML} $\rightarrow$ \ac{XML} $\rightarrow$
\ac{YAML}, y comparar los grafos resultantes de procesar los
documentos \ac{YAML} original y final. Si son equivalentes, dado que
\ac{YAXML} opera únicamente sobre el documento \ac{XML}, sabremos que
éste contiene toda la información del \ac{YAML} original sin
cambios. Se puede ver un esquema del proceso completo en la
figura~\ref{fig:oraculo_yaxml} de la página~\pageref{fig:oraculo_yaxml}.

El principal inconveniente de este enfoque es que \ac{YAXML} también
introduce sus propios fallos, y éstos son vistos como fallos de
\yaxml{} por el conjunto de pruebas. Esto no tiene por qué ser malo:
de hecho, puede verse como una forma de depurar los dos programas al
mismo tiempo, usando \yaxml{} como parte del oráculo de \ac{YAXML} y
viceversa.

Tiene la ventaja de ser completamente automático: añadir un nuevo caso
de prueba es simplemente añadir un fichero \fichero{.yaml} bajo el
directorio \fichero{t/testInputs}.

\begin{figure}
  \centering
  \includegraphics[width=.7\textwidth]{desarrollo/diseno/oraculo_yaxml}
  \caption{Oráculo de pruebas para \nombreyaxml{}}
  \label{fig:oraculo_yaxml}
\end{figure}

\subsubsection{Limitaciones de Perl frente a \acs{YAML}}
\label{sec:limitaciones}

\ac{YAML} se caracteriza por ser una especificación muy flexible,
pudiendo combinar los tipos básicos de nodos y etiquetas de muchas
formas. Este fragmento de la especificación~\cite{YAML}, que describe
a los nodos de vector asociativo, es particularmente interesante:

\begin{quotation}
  The content of a mapping node is an unordered set of key: value node
  pairs, with the restriction that each of the keys is unique. YAML
  places no further restrictions on the nodes. In particular, keys may
  be arbitrary nodes, the same node may be used as the value of
  several key: value pairs, and a mapping could even contain itself as
  a key or a value (directly or indirectly).
\end{quotation}

Como vemos, podemos tener claves no escalares e incluso referencias
cíclicas de un mapa como clave de uno de sus elementos. El problema de
los ciclos ya ha sido superado gracias a las anclas y alias, pero usar
claves no escalares es más difícil de resolver: los vectores
asociativos de Perl, usados como estructura de datos nativa por
\modulo{YAML::XS}, no admiten claves no escalares.

Existen módulos como \modulo{Tie::RefHash} que permiten usar clases
que implementan vectores asociativos con claves escalares y no
escalares como si fueran vectores asociativos normales, pero no los
reemplaza directamente, sino que modifica la forma en que Perl evalúa
el código que usa el identificador de la variable ``sobrecargada''. Es
una técnica de bajo nivel: no podemos pasar ese vector asociativo y
usarlo en una subrutina como de costumbre, por ejemplo. Además, y lo
que es más grave, no nos sirve una vez \modulo{YAML::XS} ha terminado
su procesado: tendría que usarse antes de asignarle cualquier
elemento.

Si usáramos los diccionarios de Python, por ejemplo, uno podría
imaginarse emular claves basadas en nodos secuencia mediante tuplas, y
claves basadas en nodos de vector asociativo usando tuplas de
tuplas. Python no permite usar listas ni diccionarios como claves. Sin
embargo, al igual que en el caso de Perl, todo dependería del
\emph{binding} que estuviéramos usando en ese momento.

De todas formas, examinando los lenguajes basados en \ac{YAML}
disponibles actualmente, no parece ser una restricción importante: aún
no he podido encontrar un solo formato basado en \ac{YAML} que tenga
claves no escalares. \ac{JSON} sencillamente no tiene este problema.

Por ello, por lo pronto esta restricción se considera de baja
prioridad: solventarla requeriría la reescritura completa de \yaxml{}
bajo otro entorno (seguramente una aplicación escrita en C, \CPP o
Python), y no supondría realmente una ventaja para su uso general.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../../memoria"
%%% End: 
