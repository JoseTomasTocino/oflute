%%
%% Capa de filtrado: ACL2
%% Copyright (C) 2008 Antonio García Domínguez
%% $Id: capa_filtrado_acl2.tex 629 2008-07-06 13:47:58Z antonio $
%%

Volviendo al diagrama de capas de la figura~\ref{fig:arquitec_capas}
de la página~\pageref{fig:arquitec_capas}, vemos que este conversor ha
de:
\begin{itemize}
\item Convertir la salida de \ac{ACL2} a \ac{XML} sin pérdidas.
\item Definir claramente el formato de dicha salida.
\end{itemize}

Por la necesidad de manipular el texto de la forma más sencilla y
potente posible, se escogió usar un guión escrito en Perl, un lenguaje
diseñado a este efecto.

A raíz de la complejidad inherente en el manejo de la salida en
lenguaje humano de un programa como \ac{ACL2}, se ha seguido el
paradigma orientado a objetos a la hora de desarrollar
\postprocesador{}.

\subsubsection{Procesado general de proyectos de \acs{ACL2}}
\label{sec:postproc_estruc_general}

El diseño básico se fundamenta en el modelo conceptual de datos, con
ciertas modificaciones. El guión lanzado por la capa de aplicación
emplea la función \funcion{convertir\_a\_xml} del módulo
\clase{Procesador}, pasándole la ruta al \clase{Enunciado} raíz del
proyecto completo, y vuelca sus resultados por la salida estándar.

Este método es realmente un envoltorio que crea un \clase{Proyecto}
con raíz en el \clase{Enunciado} indicado, actualiza por completo de
forma recursiva todas las salidas de \ac{ACL2} y sus versiones en
\ac{XML} y devuelve la versión \ac{XML} de la salida de la raíz del
proyecto.

Las \clase{Dependencias} del \clase{Proyecto} son obtenidas a partir
de un análisis estático del código Lisp, empezando por el
\clase{Enunciado} Lisp raíz y continuando de forma recursiva. Esto
genera un árbol anidado de \clase{Proyecto}s que dependen unos de
otros. Decimos árbol y no grafo pues un subproyecto puede aparecer
varias veces en el mismo árbol. Esto supone un coste mayor en espacio,
pero no en tiempo: si tuviera que ser actualizado, sólo sería
procesado una vez. Se están considerando representaciones más
eficientes en espacio para versiones posteriores.

El proceso de actualización consiste en recorrer el árbol e ir
actualizando de forma recursiva:

\begin{enumerate}
\item Se solicita la actualización de las \clase{Dependencias} del
  proyecto actual, que forman \clase{Proyecto}s a su vez.

\item Si algún subproyecto fue actualizado o el fichero temporal con
  la salida de \ac{ACL2} no existe o tiene una fecha de modificación
  más antigua que la del \clase{Enunciado}, se invocará a \ac{ACL2}
  para crear o actualizar dicho fichero temporal.

\item Si el fichero temporal con la salida fue actualizado o el
  fichero temporal con el documento \ac{XML} resultante no existe o
  tiene una fecha de modificación más antigua que la de la salida, se
  actualizará empleando una instancia de la clase
  \clase{Demostración}, que encapsula el proceso de análisis de una
  demostración de \ac{ACL2}.
\end{enumerate}

El diagrama de secuencia correspondiente a esta lógica se halla en el
cuadro~\ref{fig:ds_filtrado_general} de la
página~\pageref{fig:ds_filtrado_general}. El diagrama con las clases
participantes, integradas con las ocupadas de procesar las
\clase{Demostracion}es en sí, forma el
cuadro~\ref{fig:diag_clases_diseno_pproc} de la
página~\pageref{fig:diag_clases_diseno_pproc}.

\begin{sidewaysfigure}
  \centering
  \includegraphics[width=\textwidth]{desarrollo/diseno/clases_acl2proc_general}
  \caption{Diagrama de clases de \postprocesador{} (general)}
  \label{fig:diag_clases_diseno_pproc}
\end{sidewaysfigure}

\begin{sidewaysfigure}
  \centering
  \includegraphics[width=\textwidth]{desarrollo/diseno/diag_sec_acl2proc_general}
  \caption{Diagrama de secuencia general de filtrado}
  \label{fig:ds_filtrado_general}
\end{sidewaysfigure}

\subsubsection{Generación de modelos en memoria}

Un concepto importante para comprender el diseño de \postprocesador{}
en esta versión es la necesidad cada vez mayor de atrasar el momento
de la generación de la salida \ac{XML}. Originalmente, ambos estaban
intercalados. Sin embargo, en muchos casos el orden en que se procesa
la información no coincide con el orden en que se debe producir la
salida, y esto suponía un impedimento para el procesamiento de
demostraciones cada vez más complejas.

A lo largo de las iteraciones, se ha hecho una división mayor y mayor,
hasta finalmente separar el procesado y la salida a nivel de una
\clase{Demostración} completa, en vez de \clase{Resultado}s
individuales.  Esto permite dar nuevos usos al análisis ya
implementado. Puede verse esta separación en el diagrama de secuencia
de la figura~\ref{fig:ds_filtrado_demo} de la
página~\pageref{fig:ds_filtrado_demo}: la inicialización se hace sólo
durante la ejecución del constructor \metodo{new}, y la salida se
produce exclusivamente dentro del método \metodo{escribir\_xml}.

Por ejemplo, se puede analizar una \clase{Demostración} sin contar con
su salida, realizando un análisis estático sobre el código Lisp: toda
\clase{Orden} dispone de métodos separados para recuperar información
de la S-expresión y de la salida de \ac{ACL2}, y el último sólo es
usado cuando se proporciona dicha salida en el constructor. Este
análisis estático proporciona información de todas las dependencias de
un proyecto.

\begin{sidewaysfigure}
  \centering
  \includegraphics[width=.8\textwidth]{desarrollo/diseno/diag_sec_acl2proc_demostracion}
  \caption{Diagrama de secuencia de filtrado de una \clase{Demostración}}
  \label{fig:ds_filtrado_demo}
\end{sidewaysfigure}

\subsubsection{Relación con capa de servicios técnicos}
\label{sec:postproc_servtecnicos}
\index{árbol Perl}

Viendo el diagrama general de clases de diseño para la capa de
filtrado, se puede observar que la mayoría de las clases tienen
dependencias con \clase{XML::Writer} y \clase{Localización}.

Esto es lo usual con los elementos de la capa de servicios técnicos:
\clase{XML::Writer} es un módulo usado para la salida \ac{XML}, que
incorpora ciertas comprobaciones automáticas para garantizar la
ejecución de generación de documentos bien formados, y
\clase{Localización} es el módulo usado para localización de mensajes
de error o avisos.

No hay que confundir dichos servicios técnicos con clases de utilidad
como \clase{AnálisisLisp}, que aísla la lógica necesaria para
convertir listas y árboles Lisp a estructuras de datos equivalentes de
Perl.

\subsubsection{Reflexión y tipos basados en comportamiento:
  simplificación del análisis estático}
\label{sec:acl2proc_reflexion}

Al implementar el análisis estático necesario para conseguir el grafo
de dependencias de un proyecto, surge la necesidad de conocer cuál
sería el identificador final y paquete de cada evento, y de las rutas
de todos los libros. Evidentemente, hay que distinguir entre los
\clase{Evento}s con nombre, los \clase{Evento}s sin nombre y los
\clase{NoEvento}s, que no producen cambios en el mundo lógico de
\ac{ACL2}.

Sin embargo, se desea conservar toda la lógica propia a cada orden en
su propia subclase de \clase{Orden}. La forma más lógica sería añadir
niveles a la estructura de herencia, distinguiendo así entre los
\clase{Evento}s con nombre, los \clase{Evento}s sin nombre y los
\clase{NoEvento}s, pero esto sólo resolvería parte del problema:
seguiríamos teniendo que preguntar si la \clase{Orden} usada pertenece
a la lista de aquellas que afectan al paquete actual, o de la lista de
\clase{Orden}es ocupadas del manejo de libros. Tendríamos entonces que
utilizar herencia múltiple. Como vemos, preguntar por la subclase
exacta de la \clase{Orden} según el criterio que necesitemos en un
momento determinado añade una complejidad al código y crea un
acoplamiento mucho mayor de lo esperado.

\index{duck typing}

La alternativa se halla en el concepto conocido como ``duck
typing''~\cite{Martelli2000}, muy popular en lenguajes con sistemas de
tipos dinámicos como Python, y defendido (aunque no bajo ese mismo
nombre) por autores como Bruce Eckel~\cite{EckelDuckTyping}. La
definición del glosario de Python~\cite{DuckTyping} es la siguiente:

\begin{quotation}
  Pythonic programming style that determines an object's type by
  inspection of its method or attribute signature rather than by
  explicit relationship to some type object ("If it looks like a duck
  and quacks like a duck, it must be a duck.") By emphasizing
  interfaces rather than specific types, well-designed code improves
  its flexibility by allowing polymorphic substitution. Duck-typing
  avoids tests using type() or isinstance(). Instead, it typically
  employs hasattr() tests or EAFP programming.
\end{quotation}

Es decir, no distinguimos a los tipos por ``quiénes'' son, con
\verb#instanceof# en Java o \verb#typeid# en \CPP, por ejemplo, y
luego hacemos \emph{upcasting} a una clase o interfaz común. En su
lugar, los distinguimos por cómo se comportan: si \verb#anda()# como
un \clase{Pato} y \verb#hace_cuac()# como un \clase{Pato}, entonces es
un \clase{Pato} para nuestro código.

Se podría ver el ``duck typing'' como una versión de la programación
genérica de \CPP en que la comprobación de tipos se hace en tiempo de
ejecución y sólo se requieren aquellos métodos que son realmente
usados, en vez de todos las que aparecen en el código.

\index{EAFP}

Existen dos estilos para su implementación, como sugiere la definición
anterior. El segundo estilo hace referencia al acrónimo \ac{EAFP}:
asumimos que los métodos necesarios se implementan y capturamos los
errores si nos equivocamos. Dado que en el análisis estático se
mezclan las \clase{Orden}es que cumplen o no cada uno de los criterios
libremente, este método no nos sirve: el manejo de excepciones no es
un mecanismo de control de flujo, al fin y al cabo.

\index{reflexión}

El primer método sí es útil, pero notemos que hace uso de algo que no
todo lenguaje tiene: la capacidad de consultar y operar sobre la
propia estructura del programa, en tiempo de ejecución. Dicho proceso
es conocido como \emph{reflexión}, y se halla integrado dentro de
muchos lenguajes, como Java, C\#, Perl o Python.

Así, el análisis estático asume que si una clase implementa el método
\metodo{get\_nombre\_paquete} cambia el paquete actual, si implementa
\metodo{get\_identificador\_evento} representa a un \clase{Evento} con
un nombre referenciable posteriormente, y si implementa el método
\metodo{get\_ruta\_libro}, que de alguna forma ha incluido los
contenidos del libro bajo la ruta especificada bajo el mundo lógico de
\ac{ACL2}.

\subsubsection{Patrón Método Fábrica: creación de Órdenes y Procesos}
\label{sec:postproc_patron_fabrica}
\index{patrón de diseño!Método Fábrica}
\index{Método Fábrica|see{patrón de diseño!Método Fábrica}}

Se usó el patrón \patron{Método Fábrica} de~\cite{gof} para aislar
al resto del post-procesador de la lógica necesaria para identificar
qué tipo de \clase{Orden} o \clase{Proceso} hay que crear exactamente.

Podemos ver en el diagrama de clases de diseño general de la
figura~\ref{fig:diag_clases_diseno_pproc} en la
página~\pageref{fig:diag_clases_diseno_pproc} dos clases abstractas,
\clase{Orden} y \clase{Proceso}. Las instancias de sus subclases se
crean mediante los métodos \metodo{crear} de
\clase{ACL2::Orden::Fabrica} y \clase{ACL2::Proceso::Fabrica}.

\index{paquete Lisp}

En ambos casos, son los valores de los argumentos proporcionados los
que determinan qué subclase concreta de la clase abstracta base se va
a crear. En el caso de \clase{Orden}, se envía la S-expresión, el
paquete Lisp actual y la salida. En el caso de \clase{Proceso}, se
envía la salida.

\clase{ACL2::Proceso::Fabrica} requiere algo más de participación por
parte de las subclases de Proceso. Todas deben registrar una subrutina
anónima que determine si la salida enviada por \clase{Meta} se
corresponde con ella, y que devuelva los parámetros requeridos al
constructor en dicho caso. Esto podría considerarse como un uso del
patrón \patron{Orden}, descrito en más detalle en la capa de
presentación.

Dicha fábrica queda así como un punto central fácilmente accesible por
\clase{Meta} de creación de \clase{Proceso}s, y la lógica específica a
cada proceso se halla concentrada y separada del resto en un único
fichero.


\subsubsection{Patrón Método Plantilla}
\label{sec:postproc_patron_metplantilla}
\index{patrón de diseño!Método Plantilla}
\index{Método Plantilla|see{patrón de diseño!Método Plantilla}}
\index{operaciones de enganche}

Este patrón, también proveniente de~\cite{gof}, se usa en la jerarquía
de \clase{Orden} para reunir todo el comportamiento común en el
filtrado de las órdenes.

Toda orden en \ac{ACL2} produce una serie de mensajes de error, aviso
u observación. También se añade usualmente (pero no siempre) un
sumario, cuyo formato es fijo en toda orden. Se da además que la
lógica de manejo de errores de \ac{ACL2} es siempre la misma.

Toda esta lógica común es reunida en un método de una clase base, que
emplea una serie de ``operaciones de enganche'' protegidas, que
permiten especializar mediante herencia partes de ese método con la
lógica específica para cada orden, facilitando añadir nuevas órdenes o
modificar las existentes. El nombre de ``método plantilla'' viene de
esa capacidad de rellenar los ``huecos'' de su lógica.

\clase{Orden} dispone de dos métodos plantilla:

\begin{enumerate}
\item \metodo{inicializar} dispone de los enganches:
  \begin{itemize}
  \item \metodo{protegido\_inicializar\_sexpr}: operación abstracta.
  \item \metodo{protegido\_inicializar\_salida}: operación abstracta.
  \item \metodo{protegido\_extraer\_sumario}: tiene una implementación
    por defecto.
  \end{itemize}

\item \metodo{escribir\_xml} se puede especializar a partir de:

  \begin{itemize}
  \item \metodo{protegido\_cabecera}: tiene una implementación por
    defecto.
  \item \metodo{protegido\_cuerpo}: operación abstracta.
  \item \metodo{protegido\_final}: tiene una implementación por
    defecto.
  \end{itemize}
\end{enumerate}

El uso del prefijo ``\metodo{protegido\_}'' en los nombres se trata de
un esquema de nombrado, siguiendo la práctica común en muchos módulos
del \ac{CPAN}, y no implica la existencia de un mecanismo de control
de acceso real, por sencillez.

\subsubsection{Jerarquía de Órdenes}
\label{sec:postproc_jerarq_ordenes}

El diagrama de clases de diseño \ac{UML} puede verse en la
figura~\ref{fig:postproc_jerarq_ordenes} de la
página~\pageref{fig:postproc_jerarq_ordenes}.

Puede verse como cada clase redefine los métodos de enganche
necesarios, añadiendo algunas operaciones privadas para su propia
funcionalidad.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{desarrollo/diseno/clases_acl2proc_ordenes}
  \caption{Diagrama de clases de Órdenes de \postprocesador{}}
  \label{fig:postproc_jerarq_ordenes}
\end{figure}

\subsubsection{Jerarquía de Procesos}
\label{sec:postproc_jerarq_procesos}

El diagrama de esta jerarquía se halla en la
figura~\ref{fig:postproc_jerarq_procesos} de la
página~\pageref{fig:postproc_jerarq_procesos}.

Los métodos privados estáticos \metodo{\_identificar} contienen el
código que se registra en la \clase{Fábrica}, utilizando una subrutina
anónima (parecida a una clausura lambda). Para ocultar los detalles,
\clase{Fábrica} emula en su método \metodo{registrar} control de
acceso por paquete.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{desarrollo/diseno/clases_acl2proc_procesos}
  \caption{Diagrama de clases de Procesos de \postprocesador{}}
  \label{fig:postproc_jerarq_procesos}
\end{figure}

\subsubsection{Un ejemplo: definición de teorema}
\label{sec:postproc_ejemplo_defthm}

Para explicar en más detalle qué es lo que se requiere para el
filtrado de una orden de \ac{ACL2}, usaremos como ejemplo el procesado
de un supuesto evento de definición de un teorema, \texttt{defthm}.

\index{patrón de diseño!Fábrica Abstracta}

Tras crearse la \clase{Orden} a través de la \patron{Fábrica
  Abstracta} \clase{Orden::Fabrica}, se generará la versión \ac{XML}
de la salida de \ac{ACL2} en dos pasos. Cada paso se corresponde con
uno de los métodos plantilla antes mencionados.

En primer lugar, se captura toda la información disponible en la
salida de \ac{ACL2} (si se proporciona) y la S-expresión original
mediante \metodo{inicializar}:

\begin{enumerate}
\item \metodo{\_init\_desde\_salida} definido por \clase{Orden} retira
  toda la información de la salida no específica a la \clase{Orden}
  \clase{Defthm}, simplificando así su inicialización.

  Ello incluye retirar los mensajes de \ac{ACL2}, los mensajes del
  colector de basura del intérprete Lisp y el sumario de la ejecución
  de la orden.

\item \metodo{protegido\_inicializar\_sexpr}, propio de
  \clase{Defthm}, obtiene información específica a \clase{Defthm} a
  partir de su S-expresión:

  \begin{itemize}
  \item Fórmula a demostrar.

  \item Nombre del teorema.

  \item Clases de regla a generar, con el valor por defecto
    ``:REWRITE'', indicando que se usará una regla de reescritura de
    miembros.

  \item Activación o desactivación de la bandera OTF (``on through the
    fog''), obligando a \ac{ACL2} a que, si con sólo simplificar no
    basta, no intente inducir sobre la fórmula original, sino sobre
    las múltiples fórmulas resultantes de las simplificaciones.

  \item Captura de otros argumentos de interés.
  \end{itemize}

\item \metodo{protegido\_inicializar\_salida}, definido por
  \clase{Defthm}, se ocupa de recabar toda la información de interés
  del texto de la salida de \ac{ACL2}. Nos interesan las dependencias
  de almacenamiento de las reglas generadas, y los pasos de la
  demostración realizada.

  En primer lugar, recuperaremos la información mediante el método
  plantilla \metodo{inicializar}:

  \begin{enumerate}
  \item Obtener cada una de las metas e inicializarlas. Tras dividir
    la salida completa en la salida de cada meta, se empleará el
    \patron{Método Fábrica} \metodo{crear} de
    \clase{Proceso::Fabrica}, que invocará a las subrutinas anónimas
    registradas para reconocer e instanciar el \clase{Proceso} exacto
    seguido.

    Cada meta introducida se guardará en un vector asociativo para el
    siguiente paso, utilizando su etiqueta, como ``Subgoal *1''.

  \item Organizar jerárquicamente las metas. 

    Esto se puede hacer fácilmente a partir de las etiquetas: una meta
    con la etiqueta ``Subgoal *1.1'' tiene como padre la meta con la
    etiqueta ``Subgoal *1'', por ejemplo.

    Gracias al vector asociativo anterior, sólo hay que calcular la
    etiqueta del padre, recuperarlo y añadirle la submeta.
  \end{enumerate}
\end{enumerate}

A continuación, invocaremos al otro método plantilla,
\metodo{escribir\_xml}, para obtener el documento \ac{XML} que lista
toda la información antes recogida:
  
\begin{enumerate}
\item \metodo{protegido\_cabecera}: escritura de la cabecera de la
  salida \ac{XML} correspondiente al \texttt{defthm}. Se abre un nuevo
  elemento \texttt{defthm} mediante \metodo{startTag} de
  \clase{XML::Writer}.

\item \metodo{\_escribir\_mensajes}: este método es parte de la
  funcionalidad implementada por \clase{Orden}, y vuelca los mensajes
  de \ac{ACL2}: avisos, observaciones y errores.

\item \metodo{protegido\_cuerpo}: escritura del cuerpo de la salida
  \ac{XML} del \texttt{defthm}. Se vuelca la información conseguida
  antes en \metodo{protegido\_inicializar}, incluyendo la
  demostración, delegando en el método \metodo{escribir\_xml} de
  \clase{Resultado}.

\item \metodo{\_escribir\_sumario}: también parte de la funcionalidad
  predefinida por \clase{Orden}, vuelca el sumario de la ejecución del
  evento, incluyendo tiempos, reglas usadas y avisos dados.

\item \metodo{protegido\_final}: en este caso, \texttt{defthm} no
  redefine la funcionalidad predefinida por \clase{Orden}, cerrándose
  el elemento inicial escrito en \metodo{protegido\_cabecera} con un
  elemento del mismo nombre que la orden.
\end{enumerate}

Se ha descrito también de manera gráfica este proceso utilizando
diagramas de secuencia \ac{UML} 1.4. Se necesitó dividir el diagrama
en dos: el primero, dedicado al análisis, es la
figura~\ref{fig:ds_filtrado_defthm} de la
página~\pageref{fig:ds_filtrado_defthm}, y el segundo, dedicado a la
salida, es la figura~\ref{fig:ds_filtrado_defthm_2} de la
página~\pageref{fig:ds_filtrado_defthm_2}.

Por razones de espacio, algunas de las líneas de vida no se extienden
hasta el final de la hoja, sin que esto implique su destrucción. El
nivel de detalle escogido no describe las operaciones internas de
\clase{Orden} o \clase{Defthm} que no requieran interacción por parte
de otras clases, o los mensajes de poco interés enviados a
\clase{XML::Writer}.

Los vectores asociativos de Perl han sido modelados como objetos de la
clase \clase{Hash}, por uniformidad.

\begin{sidewaysfigure}
  \centering
  \includegraphics[width=\textwidth]{desarrollo/diseno/diag_sec_acl2proc_defthm_analisis}
  \caption{Diagrama de secuencia de filtrado de \texttt{defthm} (análisis)}
  \label{fig:ds_filtrado_defthm}
\end{sidewaysfigure}

\begin{sidewaysfigure}
  \centering
  \includegraphics[width=\textwidth]{desarrollo/diseno/diag_sec_acl2proc_defthm_salida}
  \caption{Diagrama de secuencia de filtrado de \texttt{defthm} (generación de salida)}
  \label{fig:ds_filtrado_defthm_2}
\end{sidewaysfigure}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../../memoria"
%%% End: 
