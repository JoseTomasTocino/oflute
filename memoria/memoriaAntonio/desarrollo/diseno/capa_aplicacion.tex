%%
%% Diseño de la capa de aplicación
%% Copyright (C) 2008 Antonio García Domínguez
%% $Id: capa_aplicacion.tex 622 2008-07-02 09:46:47Z antonio $
%%

La capa de aplicación se ocupa de implementar las clases del modelo de
la arquitectura \ac{MVP}, y de proveer servicios de alto nivel
independientes de la interfaz gráfica. Esto permite tener separados
todos los aspectos de la interfaz gráfica respecto de aquellos
relacionados con la lógica básica de \visor{}.

Veremos a continuación cuáles son esas clases del modelo y servicios
ofrecidos, y qué diseño siguen.

%% Cambio de un enfoque basado en patrones a un enfoque en
%% componentes: no es cuestión de decir "mira, usamos patrones", sino
%% "este componente, por estas razones, ha requerido este patrón, con
%% estos ajustes"

\subsubsection{Modelos de documentos}

% ModeloDocumento (comparar con ModeloPresentaciónDocumento)

El concepto fundamental en \visor{} es el de un \clase{Documento}
\ac{XML} abierto por el usuario y preprocesado. Esta clase se ocupa de
encapsular toda esa información y gestionar los cambios en la hoja de
preprocesado utilizada y la realización de búsquedas.

Nótese que no se ocupa de la hoja de visualización: como detalle de
presentación de que se trata, este aspecto se gestiona en su modelo de
presentación, que veremos en \S\ref{sec:capa_presentacion_docs}
(página~\pageref{sec:capa_presentacion_docs}).

Este modelo de documento integra los predicados de búsquedas mediante
palabra completa e ignorando minúsculas definidos mediante extensiones
XPath, dejando a las capas superiores únicamente la responsabilidad de
definir las \clase{PeticionBusqueda} necesarias.

El conjunto de todas las clases empleadas, tanto del J2SE como de
\visor{}, se halla en el cuadro~\ref{fig:apl_docs}
(página~\pageref{fig:apl_docs}).

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{desarrollo/diseno/clases_xmleye_apl_documentos}
  \caption{Diagrama de clases de diseño para modelado de documentos}
  \label{fig:apl_docs}
\end{figure}

\subsubsection{Hojas de estilos}

Las hojas de estilos participan tanto en la capa de presentación como
en la capa de aplicación. En la capa de aplicación se halla toda la
infraestructura necesaria para su ejecución, atendiendo a su
estructuración en repositorios y soporte para localización, en
combinación con el uso de herencia entre distintas hojas. Las propias
hojas son parte de la capa de presentación.

Distinguiremos entre:

\begin{description}
\item[Hoja de usuario] 
  \index{hoja de usuario!definición}
  \index{hoja de usuario!punto de acceso}
  \index{hoja de usuario!preprocesado}
  \index{hoja de usuario!visualización}

  Conjunto cohesivo de una o más hojas \ac{XSLT} individuales
  seleccionable por el usuario que conforma un modo de preprocesar el
  documento o visualizar un nodo.

  Se distinguen dos tipos:
  \begin{description}
  \item[Preprocesado]
    Contienen transformaciones que afectan al documento \ac{XML}
    completo tras su apertura. Se usan para modificar el árbol del
    documento o para realizar operaciones costosas como el
    establecimiento de enlaces.

  \item[Visualización] Contienen transformaciones a ejecutar sobre el
    nodo \ac{DOM} seleccionado por el usuario en cada momento.
  \end{description}

  Toda hoja de usuario contiene una o varias hojas \ac{XSLT}
  especiales cuyo nombre de fichero sigue el patrón \fichero{(nombre
    hoja)[idioma[\_país]].xsl}, donde [] indica una parte opcional y
  () una parte obligatoria. Llamamos a dichas hojas sus \emph{puntos
    de acceso}. Se intentará antes acceder a los puntos de acceso más
  específicos respecto del país e idioma de la localización actual.

\item[Hoja \ac{XSLT}] Fichero individual que contiene un documento
  \ac{XML} definido sobre el vocabulario \ac{W3C} \ac{XSLT}.

\end{description}

Las hojas de usuario han de organizarse cumpliendo una serie de
requisitos:

\begin{itemize}
\item Han de poder ser fácilmente localizables según el país y el
  idioma de la localización establecida por el usuario por defecto en
  su sistema.

\item Han de ser fáciles de instalar, sin requerir configuración
  alguna.

\item Han de ser fáciles de elaborar, pudiendo basarnos en hojas de
  usuario ya existentes.
\end{itemize}

Los detalles de implementación de cada tipo de hoja de usuario y
aquellos comunes a toda hoja de usuario han sido encapsulados en
clases, permitiendo a la capa de presentación realizar
transformaciones sin conocer los detalles de la biblioteca \ac{XSLT}
usada.

En cuanto a los requisitos sobre la organización de las hojas de
usuario, se ha mantenido la separación de responsabilidades moviendo
estos requisitos a una clase que actúa de \emph{repositorio}, que se
ocupa de localizar las hojas de usuario y configurarlas para conseguir
al mismo tiempo la capacidad de reutilizar código y localizar las
hojas. La carga del repositorio se realiza al iniciar \visor{}.

La organización general de las clases utilizadas se halla en la
figura~\ref{fig:apl_hojasusuario} de la página~\pageref{fig:apl_hojasusuario}.

\paragraph{Organización del repositorio}

El esquema de almacenamiento del repositorio no es configurable,
siendo así posiblemente menos flexible, pero muy sencillo de
utilizar. La organización de las hojas de usuario se explica mejor con
un ejemplo. Una posible distribución de hojas \ac{XSLT} de una
hipotética hoja de usuario de visualización llamada \fichero{perso}
bajo el directorio base con la ruta relativa \fichero{xslt} sería:

\begin{itemize}
\item \fichero{xslt/view/perso/perso.xsl}: punto de acceso inicial
  para la localización por omisión.
\item \fichero{xslt/view/perso/perso\_en.xsl}: punto de acceso inicial
  para la localización inglesa, sin especificar el país.
\item \fichero{xslt/view/perso/perso\_en\_GB.xsl}: punto de acceso
  inicial para la localización inglesa en el Reino Unido.
\item \fichero{xslt/view/perso/logica.xsl}: hoja complementaria que
  permite que los tres idiomas compartan la misma lógica.
\end{itemize}

Si fuera una hoja de preprocesamiento, se usaría \fichero{preproc} en
vez de \fichero{view}.

\paragraph{Extensibilidad}
\label{sec:cod_xsl_acceso}

Las hojas de usuario son importadas por la hoja principal no
modificable de su tipo, en la raíz del repositorio, que define la
mínima funcionalidad común: \fichero{view.xsl} para las hojas de
visualización y \fichero{preproc.xsl} para las de preprocesado.

Además, una hoja de usuario puede importar a otras y así
especializarlas. Es el caso de \fichero{ppACL2}, que importa a
\fichero{xml}.

Para abstraer a las hojas de la lógica de internacionalización, una
hoja de usuario que desee importar a otra puede usar \ac{URI}
especiales como \texttt{view\_ppACL2}. 

Mediante esta \ac{URI}, se accederá a la hoja de usuario de
visualización \fichero{ppACL2} a través del punto de acceso que mejor
se ajuste a la localización actual del usuario.

\paragraph{Internacionalización}
\label{sec:cod_xsl_l10n}

El ejemplo de \fichero{perso} anterior ilustra el mecanismo de
localización establecido por la lógica de la capa de aplicación. Dicho
mecanismo imita al usado por los \clase{ResourceBundle}s de la
biblioteca estándar de Java.

Si la localización  actual por defecto es ``es\_ES'' (español, España) y se
busca la hoja de visualización \fichero{ppACL2},
\clase{ControlHojasXSL} intentará localizar un punto de acceso en el
siguiente orden:
\begin{enumerate}
\item \fichero{xslt/view/ppACL2/ppACL2\_es\_ES.xsl}
\item \fichero{xslt/view/ppACL2/ppACL2\_es.xsl}
\item \fichero{xslt/view/ppACL2/ppACL2.xsl}
\end{enumerate}

\begin{figure}
  \centering
  \includegraphics[width=.9\textwidth]{desarrollo/diseno/clases_xmleye_apl_hojas}
  \caption{Diagrama de clases de diseño para las hojas de usuario}
  \label{fig:apl_hojasusuario}
\end{figure}

\subsubsection{Descriptores de formatos}

Otro servicio también a prestar por la capa de aplicación es el de la
gestión de los descriptores de formatos de documento. Al igual que en
el caso de las hojas, se necesitaba abstraer a las capas superiores de
los detalles de un descriptor individual y de la forma en que se
hallan organizados.

Volvemos a tener otro repositorio, esta vez de descriptores, en el que
se siguen una serie de convenciones para evitar la necesidad de
realizar cualquier tipo de configuración. A diferencia del repositorio
de hojas, no tratamos con un único árbol de directorios: se pueden
encadenar varios, y así poder tener una serie de ajustes a nivel
global para todos los usuarios, y otros locales para el usuario
actual. Para restaurar los ajustes locales a los globales, sólo hemos
de borrar el descriptor a nivel local y actualizarlos.

\index{patrón de diseño!Observador}
\index{Singleton|see{patrón de diseño!Observador}}

Este repositorio abstrae también la lógica que hace corresponder un
descriptor a un fichero determinado, y se ocupa de validar contra un
XML Schema todos los descriptores. El repositorio es un
\clase{AbstractListModel} de Swing, por lo que puede integrarse
fácilmente como modelo de un formulario e incluso registrar
\patron{Observador}es sobre él si se estima necesario, pero no es obligatorio.

Por otro lado, las clases para los descriptores individuales
encapsulan el formato de estos ficheros y proporcionan toda la
validación necesaria de su contenido, lanzando excepciones cuando se
intentan establecer valores no válidos en algún atributo.

Las clases implicadas se hallan en el
cuadro~\ref{fig:aplicacion_formatos} de la
página~\pageref{fig:aplicacion_formatos}.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{desarrollo/diseno/clases_xmleye_apl_descriptores}
  \caption{Diagrama de diseño de clases de descriptores de formatos}
  \label{fig:aplicacion_formatos}
\end{figure}

% , descriptores de formatos (detalles
% de almacenamiento multinivel en repositorio, abstracción de los
% ficheros en forma de objetos, localización, restauración)

\subsubsection{Notificación de cambios sobre ficheros}

\index{patrón de diseño!Observador}
\index{Singleton|see{patrón de diseño!Observador}}

Un requisito muy interesante era el de poder vigilar los cambios
realizados sobre los documentos durante su visualización, pudiendo
mantener el editor y \visor{} abiertos en paralelo. Para ello se ha
implementado una clase que ofrece una interfaz basada en el patrón
Observador, que se basa en la fecha de modificación para notificar de
cambios en los contenidos del fichero.

Para ello, se usa un hilo en segundo plano de baja prioridad, que se
despierta cada cierto tiempo, realiza la comprobación y vuelve a
dormir. Esto evita la pérdida de rendimiento que supondría un bucle de
espera activa. Además, las actualizaciones pueden pausarse y
reactivarse a voluntad.

% Observador

\subsubsection{Persistencia de preferencias}

% Singleton (únicamente como punto de acceso, permite cambio backend en un futuro)

\label{sec:aplic_singleton}
\index{patrón de diseño!Inyección de Dependencias}
\index{patrón de diseño!Singleton}
\index{Inyección de Dependencias|see{patrón de diseño!Inyección de Dependencias}}
\index{Singleton|see{patrón de diseño!Singleton}}

En este caso es fundamental tener un punto de acceso central a todas
las preferencias de los usuarios. Por estas razones, en la versión
original del visor se utilizó el patrón \patron{Singleton}, asegurando
la existencia de una única instancia de una clase que implementara una
interfaz. Se utilizó una versión mejorada de la implementación usual
tomada de~\cite{gof}, simplificando sobre la sugerida
en~\cite{singletonjava}.

Sin embargo, durante el desarrollo de esta nueva versión, se vio que
el uso del Singleton dificultaría la posterior realización de pruebas
con sustitutos, e introducía una dependencia innecesaria. 

Para retirarla, se aplicó el patrón \patron{Inyección de
  Dependencias}: ahora no son las clases las que solicitan el gestor
de preferencias, sino las que lo reciben a través de su
constructor. De esta forma, no se necesita el punto único de acceso
como antes, siendo muy fácilmente sustituible durante pruebas, por
ejemplo, y manteniendo la independencia respecto a la implementación a
través del uso de una interfaz.

El diagrama de las clases involucradas en la gestión de preferencias
se halla en el cuadro~\ref{fig:dc_aplic_prefs} de la
página~\pageref{fig:dc_aplic_prefs}. Podemos ver que el
\patron{Singleton} ha desaparecido, al ser ahora completamente
innecesario.

Se dispone de un valor booleano almacenado directamente en
dependencias, de tal forma que una clase que requiera un atributo con
persistencia entre las preferencias sólo tendrá que instanciar
apropiadamente esta clase y luego utilizar \lstinline{get()} y
\lstinline{set()} sin más complicaciones.

%% sigue igual, pero cuidado con las fachadas

En el diagrama de secuencia~\ref{fig:ds_aplic_prefs} de la
página~\pageref{fig:ds_aplic_prefs} puede verse cómo se gestionan
las preferencias a lo largo del programa:
\begin{itemize}
\item Al iniciarse \visor{}, se crea una instancia de la clase
  principal que representa a toda la aplicación. Esta clase es la
  ocupada de ensamblar a todas las demás clases de mayor nivel,
  inyectando las dependencias consideradas oportunas y evitando que
  dependan demasiado entre sí.

\item La clase principal ensambladora crea una instancia de la
  implementación de gestión de preferencias a usar, y solicita que se
  carguen las preferencias.

\item La clase principal ensambla el modelo de presentación de la
  ventana principal con el gestor de preferencias (visto a través de
  su interfaz) y otros parámetros. También ensambla y lanza la ventana
  principal.

\item Al cerrar la aplicación, la misma clase principal solicita el
  guardado de las preferencias antes de terminar la ejecución del
  programa.

\end{itemize}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{desarrollo/diseno/clases_xmleye_apl_prefs}
  \caption{Diagrama de clases de diseño de gestión de preferencias}
  \label{fig:dc_aplic_prefs}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{desarrollo/diseno/diag_sec_xmleye_prefs}
  \caption{Diagrama de secuencia de gestión de preferencias}
  \label{fig:ds_aplic_prefs}
\end{figure}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../../memoria"
%%% End: 
