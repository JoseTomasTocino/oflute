\documentclass[a4paper,abstracton]{scrartcl}
\usepackage[spanish]{babel}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[printonlyused]{acronym-custom}
\usepackage{array}
\usepackage{listings}
\usepackage{rotating}
\usepackage{graphicx}
\usepackage{xr-hyper}
\usepackage[pdftex]{hyperref}
\usepackage{hyphenat}
\externaldocument{memoria}
\begin{document}

\input{ordenes.tex}

\begin{center}

  {\Large{} 

    \textbf{\nohyphens{Post-procesador y Visor de Demostraciones para el Sistema
        ACL2}}
  }

{\large Antonio García Domínguez, 
  Francisco Palomo Lozano\textsuperscript{1}, 
  Inmaculada Medina Bulo\textsuperscript{2}}

\textit{Av. Palestina, 23, Puerto Real, 11510 Cádiz. Tlf.: +34
  956474041. \url{antonio.garciadominguez@alum.uca.es.}}

\textsuperscript{1} \textit{E. Superior de Ingeniería, C/ Chile, 1,
  11002 Cádiz. Tlf.: +34 956 015730. \url{francisco.palomo@uca.es}}

\textsuperscript{2} \textit{E. Superior de Ingeniería, C/ Chile, 1,
  11002 Cádiz. Tlf.: +34 956 015730. \url{inmaculada.medina@uca.es}}

\end{center}

\medskip

\begin{abstract}
  El sistema de razonamiento automatizado ACL2 es conocido por haber
  resuelto casos prácticos de gran utilidad. Sin embargo, su salida
  puede llegar a ser muy difícil de comprender en demostraciones
  complejas.

  Para resolver este problema, se desarrolló un visor en Java sobre la
  salida de ACL2, post-procesada mediante un guión Perl. El visor
  utiliza hojas XSLT para dirigir las transformaciones de la salida
  XML a la visualización XHTML por datos, añadiendo información de
  forma automática.

  Se creó un marco en el visor para hacer a las hojas extensibles y
  traducibles por el usuario sin recompilaciones. Este marco es lo
  suficientemente flexible como para visualizar todo tipo de
  documentos XML, y no solamente las salidas del post-procesador.

  \textsc{Palabras clave:} razonamiento automatizado, XSLT, ACL2,
  métodos formales, visualización de demostraciones.
\end{abstract}

\bigskip

\section{Utilidad del proyecto}
\label{sec:resumen_utilidad}

\ac{ACL2} es un sistema automatizado de demostración de teoremas
publicado bajo la licencia \acs{GPL} y basado en un subconjunto
funcional puro de Common Lisp. Sus demostraciones emplean una base de
conocimientos extensible por el usuario a través de los
\emph{eventos}, una clase particular de órdenes de \ac{ACL2}.

La salida de \ac{ACL2} consiste en una mezcla de lenguaje humano y
expresiones Lisp, y puede ser muy larga y difícil de analizar para
demostraciones de interés práctico. Un ejemplo es la
verificación~\cite{conf/iccd/BrockHH97} de la corrección de la
implementación de ciertos algoritmos \ac{DSP} en el chip \ac{CAP} de
Motorola, cuya salida de \ac{ACL2} basada en un enunciado de 16000
líneas alcanzó los 84 megabytes en texto puro.

El proyecto procura resolver este problema a través de un
post-procesador a \ac{XML} sobre dicha salida, para después usar un
visor sobre el resultado. Se hará disponible bajo la licencia
\ac{GPL}.

\section{Objetivos}
\label{sec:resumen_objetivos}

Se desarrollarán por separado un post-procesador que traduzca sin
pérdidas la salida de \ac{ACL2} a \ac{XML} y un visor que permita
representar de forma flexible dicha información en varios niveles de
detalle y realizar búsquedas sobre ella, añadiendo información de
utilidad automáticamente, como las dependencias entre los elementos de
la demostración.

Para permitir el uso de la salida del post-procesador por otras
aplicaciones distintas al visor, se describirá su formato a través de
una \ac{DTD}.

Por la capacidad de establecer enlaces y su formato superior al texto
puro de \ac{ACL2}, el formato de visualización consistirá en
hipertexto, y en particular \ac{XHTML}, una versión \ac{XML} del
lenguaje \ac{HTML}.

La visualización de la demostración debe ser extensible y modificable
por el usuario sin necesidad de cambiar el código fuente del visor,
pudiendo cambiar la representación seleccionada durante la propia
ejecución del visor.

Se separarán los datos sensibles a la localización del usuario del
resto del código, facilitando la localización del proyecto a otros
idiomas. Toda la funcionalidad del visor estará disponible mediante
teclado, por razones de accesibilidad y usabilidad.

\subsection{Tipos de usuario}
\label{sec:resumen_usuarios}

El proyecto desarrollado se dirige a varios tipos de usuario:

\begin{description}
\item[Investigador o estudiante de \ac{ACL2}] El usuario realiza todo
  su trabajo desde el visor, pudiendo lanzar su editor preferido sobre
  el enunciado Lisp a demostrar, realizar cambios y dejar que el visor
  se ocupe de invocar a \ac{ACL2} y al post-procesador
  automáticamente.

\item[Desarrollador de otro visor para \ac{ACL2}] Un usuario podría
  desarrollar su propia aplicación que manipulara la salida \ac{XML}
  del post-procesador en la forma que deseara, sin llegar a tener que
  usar en absoluto el visor.

\item[Usuario no interesado en \ac{ACL2}] 
  El usuario podría adaptar la lógica de visualización del visor a
  cualquier tipo de documento \ac{XML} añadiendo las hojas \ac{XSLT}
  pertinentes. No habría ninguna necesidad entonces de utilizar el
  post-procesador.

  Las hojas \ac{XSLT} son simples documentos \ac{XML} que siguen el
  vocabulario \acs{W3C} \ac{XSLT} (ver~\cite{Clark:99:XTV}).
\end{description}

\subsection{Alcance}
\label{sec:resumen_alcance}

Por limitaciones de tiempo, sólo se ha llegado a tratar un subconjunto
limitado de la salida de \ac{ACL2}. Esto restringe la aplicación
actual del proyecto a un uso didáctico, con demostraciones que, aunque
complejas, no hacen uso de todo el potencial de \ac{ACL2}.

En futuras versiones se pretende extender la lógica de filtrado de la
salida de \ac{ACL2} para tratar casos de interés práctico.

Se ha probado el proyecto en Windows XP SP2, y en \acs{GNU}/Linux,
particularmente la distribución Ubuntu ``Dapper Drake'' 6.06.1
\ac{LTS}. Debería funcionar sin problemas en las implementaciones de
Sun de \ac{J2SE} 5.0 disponibles para otras plataformas, como Solaris
o Mac OS X.

Java es el que impone el límite de transportabilidad, y no Perl 5.8,
que ha sido transportado a todo tipo de plataformas, desde
reproductores de vídeo TiVo a sistemas operativos experimentales como
Plan 9.

\section{Desarrollo}
\label{sec:resumen_desarrollo}

\subsection{Metodología}
\label{sec:resumen_metodologia}

La metodología seguida ha sido \ac{XP}, por las ventajas que aporta
como metodología ágil de desarrollo, centrada más en obtener un
producto de valor práctico que en formalismos.

Dicha metodología intenta llevar al extremo las mejores prácticas
conocidas de la ingeniería del software, de ahí su nombre.

La metodología \ac{XP} defiende una serie de principios y valores
centrados en la comunicación directa y preferentemente oral entre los
integrantes del equipo de desarrollo y los clientes.

Para cumplir dichos valores y principios, se definen un núcleo de
prácticas obligatorias y un conjunto de tareas opcionales a seguir una
vez el núcleo esté firmemente implantado. Prácticas obligatorias por
las que \ac{XP} es conocido (y criticado) especialmente son la
programación en parejas, la programación basada en pruebas y el diseño
incremental.

\index{práctica XP!programación basada en pruebas}

La programación basada en pruebas consiste en escribir las pruebas
\emph{antes} que la propia implementación. Así, las pruebas se
convierten también en un mecanismo de diseño que obliga a los
programadores a crear una interfaz cohesiva y sencilla que facilite
dichas pruebas.

\index{práctica XP!diseño incremental}

Todas estas pruebas automatizadas permiten al equipo de desarrollo
realizar ágilmente cambios continuos sobre la estructura del programa,
garantizando la misma funcionalidad anterior. El coste del cambio se
reduce y se posibilita así el diseño incremental.

Para más detalles, referirse a la sección \S\ref{sec:proceso} de la memoria,
las obras~\cite{xpexplained,planxp}, o el sitio web que lo
empezó todo, \cite{xpwiki}.

\subsection{Análisis}
\label{sec:resumen_analisis}

\index{historia de usuario|see{práctica XP!historia de usuario}}

La recogida de requisitos mediante \ac{XP} es muy sencilla, y consiste
en la confección de simples tarjetas de papel con historias de
usuario. 

Una historia de usuario consiste en un relato en palabras del propio
usuario (y no de un analista) describiendo de forma resumida una
funcionalidad o propiedad deseada del sistema. Un ejemplo sería:
\begin{quote}
  ``Visualizar un documento \ac{XML} arbitrario en forma de árbol,
  permitiendo expandir y contraer los nodos, y buscar información.''
\end{quote}

La planificación se realiza a través de estas simples historias. Los
desarrolladores añaden una estimación de tiempo en términos de días
ideales (ver~\cite{planxp}) y un riesgo, y el cliente añade la
prioridad. En cada iteración se eligen las historias de usuario de
mayor interés para el cliente.

En la sección \S\ref{sec:analisis} de la memoria
(página~\pageref{sec:analisis}) se halla un listado exhaustivo de
todas las historias de usuario planteadas durante la realización del
PFC por mis ``clientes'', mis directores de proyecto, investigadores
especializados en \ac{ACL2} y por lo tanto partes interesadas.

También se ha realizado un estudio del dominio del problema
(demostraciones de \ac{ACL2}) mediante un diagrama de clases de
análisis, disponible en \S\ref{sec:datos_conceptual}
(página~\pageref{sec:datos_conceptual} de la memoria).

\subsection{Diseño}
\label{sec:resumen_diseno}

Tanto \visor{} como \postprocesador{} se diseñaron siguiendo el
paradigma orientado a objetos. Describiremos primero la arquitectura
general del sistema formado por \visor{} y \postprocesador{}, y luego
se describirá el diseño de cada parte.

\subsubsection{Arquitectura}
\label{sec:resumen_arquitectura}

La arquitectura a nivel global del proyecto sigue el patrón \patron{Capas}
~\cite{archpatterns}. Así, el proyecto se estructura en 4 capas:
\begin{description}
\item[Presentación] Visualización \ac{XHTML} y comunicación con el usuario.
\item[Aplicación] Lógica de control para atender a los eventos
  recibidos desde la capa de presentación.
\item[Filtrado] Filtrado de la salida de \ac{ACL2}.
\item[Servicios técnicos] Bibliotecas y módulos externos que prestan
  servicios fundamentales al proyecto.
\end{description}

\visor{} se halla en las dos capas superiores y \postprocesador{} en
la capa de filtrado. Ambos requieren servicios de la capa de servicios
técnicos.

Viendo las capas como una división a lo largo del eje vertical, se
puede realizar otra división en el eje horizontal en particiones,
responsabilidades de una capa débilmente relacionadas con las demás.
La figura~\ref{fig:res_arquitec_capas} de la
página~\pageref{fig:res_arquitec_capas} muestra ambas divisiones.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{desarrollo/diseno/arquitec_capas.pdf}
  \caption{Diagrama arquitectónico del sistema}
  \label{fig:res_arquitec_capas}
\end{figure}

A su vez, la transformación de la salida de \ac{ACL2} a la
presentación \ac{XHTML} sigue una versión del patrón \patron{Tuberías
  y Filtros}~\cite{archpatterns} no paralelizable por el uso de
\ac{XSLT}, que requiere siempre tener el documento completo.

Se tienen cuatro filtros, en este orden: \postprocesador{}, una hoja
de usuario de preprocesado del documento completo, otra hoja de
usuario de visualización de un nodo, y marcado adicional por la capa
de aplicación.

Los dos filtros intermedios son fácilmente intercambiables, dando la
flexibilidad deseada a la lógica de visualización. Además, el formato
de la salida de cada filtro se halla bien definido:
\begin{itemize}
\item En el primer filtro, disponemos de una \ac{DTD}.
\item En los dos filtros intermedios, podemos tomar el nombre de la
  hoja de usuario como referencia de la salida esperada, y, en el caso
  del filtro de visualización, también de la entrada esperada.

  Así, sabemos que la hoja \fichero{ppACL2} de visualización tomará la
  salida de la hoja \fichero{ppACL2} de preprocesado (o una
  especialización suya) y mostrará la información relevante a
  \ac{ACL2} contenida en dicho documento.
  
\item En el último filtro, sabemos que se trata de \ac{XHTML}, que
  sigue también una \ac{DTD}.
\end{itemize}

\subsubsection{Capas}
\label{sec:resumen_capas}

\begin{description}
\item[Presentación] La capa de presentación utiliza la
  \patron{Fachada} de la capa de aplicación y proporciona la suya
  propia, estableciendo un diálogo entre \patron{Fachada\/}s.

  El patrón \patron{Observador} modela la comunicación interna entre
  los componentes de esta capa, estableciendo un acoplamiento débil
  entre ellos.
  
  Se incluye un \patron{Singleton} para la visualización de mensajes y
  la petición sencilla de datos al usuario por la capa de aplicación.
  Se tomó el patrón de implementación de~\cite{singletonjava},
  separando la funcionalidad (\clase{GestorMensajes}) del punto de
  acceso global a una instancia (\clase{GestorMensajesSingleton}),
  facilitando las pruebas.

  Se especializaron algunas clases de Swing relacionadas con el
  componente \clase{JTree} para encapsular la lógica de la
  visualización de \ac{XML}. Se hizo siguiendo su \emph{arquitectura
    de modelo separable}~\cite{swingarch}, una versión simplificada
  del patrón arquitectónico \patron{Modelo-Vista-Controlador}.

\item[Aplicación] 

  La capa de aplicación define una fachada para ofrecer sus servicios
  y se comunica con la fachada de la capa de presentación.

  La \patron{Fachada} de la capa de aplicación controla además los
  hilos que realizan las tareas largas en segundo plano para mejorar
  el tiempo de respuesta de \visor{}.

  La comunicación entre los componentes de la propia capa se realiza a
  partir del patrón \patron{Observador}, atendiendo a los cambios de la hoja
  seleccionada.

  Otro Singleton permite a la capa de presentación acceder a las
  preferencias, guardadas de forma persistente al cerrar \visor{}. La
  implementación es la misma que para \clase{GestorMensajes}.

\item[Filtrado] 

  La capa de filtrado es implementada por el post-procesador.

  La comunicación con la parte Java se realiza a partir del paso de
  parámetros en su invocación y de su salida estándar. Se usa una
  \ac{DTD} en el visor y en las pruebas de regresión semiautomáticas
  para fijar el formato de la salida \ac{XML}.

  Se sigue por lo general la estructura del modelo conceptual de
  datos, usándose el patrón \patron{Fábrica Abstracta} para encapsular
  la lógica ocupada de crear instancias de las subclases de las clases
  abstractas \clase{Proceso} y \clase{Orden}.

  Al mismo tiempo, \clase{Orden} utiliza el patrón \patron{Método
    Plantilla} para aislar en un único punto la lógica común a todas
  las órdenes de \ac{ACL2}, permitiendo a las subclases redefinir el
  comportamiento por defecto para algunos de los métodos en caso
  necesario.

\end{description}
   
\subsection{Implementación}
\label{sec:resumen_implementacion}

Este apartado recoge la información de varios apartados de la memoria:
\begin{itemize}
\item \S\ref{sec:desc_restr} (página~\pageref{sec:desc_restr}),
  dedicado a las restricciones generales.
\item \S\ref{sec:implementacion}
  (página~\pageref{sec:implementacion}), dedicado a la implementación.
\end{itemize}

Se eligieron dos lenguajes de programación con implementaciones
interpretadas a través de máquinas virtuales para el proyecto, por la
mayor transportabilidad que permiten. Además, ambos incorporan
recolectores de basura, reduciendo el potencial de error.

\subsubsection{Post-procesador}
\label{sec:resumen_impl_pproc}

Perl no proporciona construcciones en el propio lenguaje para el
paradigma orientado a objetos. Sin embargo, se puede implementar a
partir de las facilidades que ofrece, como la bendición de una
referencia con el nombre de un módulo, que permite implementar los
métodos virtuales y la herencia.

Se emplearon varios módulos Perl en el desarrollo de \postprocesador{}.
Todos se hallan o bien en la distribución estándar de Perl a partir de
la versión 5.8.0, o disponibles para descarga en el \ac{CPAN}. Se
tratan de:
\begin{description}
\item[Locale::Maketext] Integrado en la distribución estándar de Perl
  a partir de la versión 5.8.0, proporciona facilidades de
  localización superiores a las de otras alternativas, como
  \texttt{Gettext}.

\item[File::Spec] Realiza transformaciones sobre rutas de ficheros de
  manera transportable.

\item[XML::Writer] Incorpora funciones para salida XML con
  comprobaciones básicas de consistencia.

\item[Pod::Usage] Permite mostrar un mensaje de uso a partir de la
  documentación \ac{POD} incrustada en el propio guión Perl.

\item[Getopt::Long] Implementa opciones de línea de órdenes siguiendo
  el estándar \ac{POSIX}.
\end{description}

\subsubsection{Visor}
\label{sec:resumen_impl_visor}

\ac{J2SE} 5.0 incorpora un nuevo \ac{API} estándar para XPath, un
reemplazo del analizador \ac{XML} basado en el proyecto Apache Xerces
y un nuevo procesador \ac{XSLT} Apache Xalan XSLTC, que permite
compilar a instrucciones de la \ac{JVM} las hojas \ac{XSLT} para
mayor rendimiento.

Utilizando estas bibliotecas evitamos dependencias externas,
exceptuando el Look \& Feel personalizado JGoodies, redistribuido con
\visor{}. Dicho Look \& Feel se halla bajo la licencia \ac{BSD}.

El manejo por teclado del componente Swing \clase{JEditorPane} usado
originalmente en la visualización de \ac{HTML} era muy inconveniente,
haciéndose incómoda la navegación y siendo imposible recorrer los
enlaces. Se creó una versión especializada, \clase{Navegador}, para
resolver estos problemas.

Se consiguió la internacionalización de la interfaz Swing a través de
los \clase{ResourceBundle} incluidos en la biblioteca del \ac{J2SE}.

El entorno de compilación consistió en un guión para Apache Ant,
sustituto de los \fichero{Makefile}s en el mundo Java. Las pruebas de
unidad se crearon a partir del marco JUnit y se lanzan automáticamente
mediante Ant.

\subsubsection{Hojas XSLT: Filtros}
\label{sec:resumen_xsl_filtros}

Usar hojas \ac{XSLT} en los dos filtros intermedios permite al usuario
cambiar su comportamiento añadiendo nuevos directorios con hojas
\ac{XSLT} al subdirectorio \fichero{xslt} del visor.

El usuario puede seleccionar distintas hojas de usuario de
preprocesado y de visualización ya predefinidas o crear sus propias
hojas. Además, las hojas de usuario pueden extender a otras, y pueden
localizarse.

Las hojas de preprocesado afectan a todo el documento transformando su
estructura o su apariencia en el árbol, y sólo se utilizan una vez.
Por el otro lado, las hojas de visualización transforman el nodo
seleccionado del documento preprocesado a \ac{XHTML}.

La organización de dichos directorios y su contenido deben seguir
ciertas convenciones, descritas en el manual del usuario del visor.

\section{Pruebas}
\label{sec:resumen_pruebas}

Se realizaron tres tipos de pruebas sobre el proyecto:
\begin{itemize}
\item Pruebas automatizadas de unidad sobre los métodos de las partes
  más importantes del visor, como los componentes para manejo de rutas
  XPath o visualización y navegación de árboles \ac{DOM} \ac{XML}. Se
  da un listado exhaustivo en la
  sección~\S\ref{sec:pruebas_visor_unidad} de la memoria.

\item Pruebas automatizadas de regresión sobre el post-procesador
  Perl, consistentes en una validación mediante una \ac{DTD} y una
  comparación con una salida previamente comprobada manualmente,
  descartándose diferencias triviales como tiempos de ejecución o
  espaciado entre elementos \ac{XML}.

  Existe un caso de prueba de este tipo por cada guión para \ac{ACL2}
  usado en el desarrollo de este programa.
  Véase~\S\ref{sec:pruebas_postprocesador} en la memoria.

\item Pruebas manuales de aceptación sobre la interfaz gráfica basadas
  en las historias de usuario planteadas acerca del visor.  Consisten
  en una lista de pasos a ejecutar y resultados esperados para cada
  paso, y se pueden consultar en la
  sección~\S\ref{sec:pruebas_visor_acept} de la memoria.

\end{itemize}

\section{Conclusiones}

Se ha conseguido, gracias a la metodología ágil \ac{XP}, entregar dos
productos funcionales de calidad, a pesar de las limitaciones de
tiempo. Se consiguió regulando continuamente el alcance del visor y el
post-procesador, reorientando gradualmente el proyecto, como indica la
metodología.

El estado del proyecto actualmente lo limita a un uso didáctico, pero
la infraestructura para extender dicha funcionalidad a casos prácticos
está ya establecida.

Se ha conseguido además cumplir con las otras propiedades deseadas en
los objetivos del proyecto, como la extensibilidad, transportabilidad,
reutilizabilidad, facilidad de localización, usabilidad y
accesibilidad. 

Es particularmente notable la capacidad de poder usar ambas partes del
proyecto por separado para fines distintos a los iniciales.

En futuras versiones, además de ampliar el subconjunto de la salida de
\ac{ACL2} a tratar, se añadirán funciones como generación de árboles
\ac{XHTML} visualizables mediante cualquier navegador, o enlazado
entre elementos de la misma demostración repartidos entre varios
ficheros. También se facilitará el proceso de instalación.

\section*{Agradecimientos}

Quisiera agradecer a mis directores, Francisco Palomo Lozano e
Inmaculada Medina Bulo, por su apoyo y sus consejos a lo largo del
proyecto.

\section*{Glosario}
\label{sec:glosario}
\input{introduccion/acronimos.tex}

\bibliographystyle{hispa}
\bibliography{bibliografia}

\end{document}

%%% Local Variables: 
%%% TeX-master: t
%%% End: 
