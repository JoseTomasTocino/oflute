\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}

\usepackage{graphicx}
\usepackage{hyperref}

\include{estiloListing}

\usepackage[top=1.7cm, bottom=1.7cm, left=1.7cm, right=1.7cm]{geometry}

%% \usepackage{multicol}
%% \setlength{\columnsep}{20pt}

\renewcommand{\familydefault}{\sfdefault}

\usepackage{setspace}
\onehalfspacing

\setlength{\parskip}{0.4cm}

\title{Mini Guía Emacs para estudiantes de ADA Y POO}
\author{José Tomás Tocino García}
\date{}

\begin{document}

\pagestyle{empty}
\begin{center}
\begin{Large}\textbf{Olvídate de la SDL: Desarrollo de juegos en C++ con Gosu}\end{Large}\\
\begin{large}José Tomás Tocino García - \texttt{<theom3ga@gmail.com>}\end{large}\\[0.1cm]

{\small Licencia CC - Reconocimiento - No comercial - Compartir igual.\\
http://creativecommons.org/licenses/by-nc-sa/2.5/es/}
 
\end{center}

¿Cuántas líneas hacen falta para hacer aparecer una imagen en pantalla
usando la biblioteca SDL? ¿Cuántas veces has implementado una clase
\texttt{Imagen} para usar orientación a objetos con la SDL? ¿Has
visto algún juego hecho con SDL ir más allá de los 70fps?

Si has usado SDL para programar juegos, conocerás las respuestas a
estas preguntas, y habrás sufrido una agonía de bajo nivel repleta de
\texttt{SDL\_Surface}, \texttt{SDL\_DisplayFormatAlpha} y demás
engendros del demonio. Una vez que tenías el motor del
juego más o menos hecho, con suerte te quedaban fuerzas para hacer a
lo sumo un par de niveles del juego.

Pero esto, señores, \textbf{s'acabao}.

\begin{center}
  \includegraphics[width=7cm]{website_header}
\end{center}

Gosu (\url{http://www.libgosu.org}) es una librería para el desarrollo
de videojuegos 2D utilizando Ruby y C++, y disponible para Mac OS X,
Windows y, oh sí, \textbf{Linux}. Incluye la gestión de gráficos (con
\textbf{aceleración 3D por OpenGL}), gestión de la entrada y
reproducción de música y sonidos, así como funciones de red.

La librería está hecha en \textbf{C++}, por lo que la orientación a
objetos es total. Además, está completamente adaptada a la \textbf{creación de
juegos}, adaptando el flujo de ejecución al game loop típico consistente
en gestionar la entrada de usuario, actualizar la lógica del juego y
finalmente imprimir los gráficos en pantalla.

\section{Requisitos previos}
Es necesario que sepas C++. Es fácil, es bonito, mola. Si no sabes
C++, corre a la biblioteca.

Al ser una librería poco conocida (al menos por ahora, pero esperad a
que este tutorial se haga famoso, MWAHAHA), no está disponible en los
repositorios de las distribuciones más famosas, ni tampoco está
empaquetada, así que hay que instalarla partiendo del código fuente.

Afortunadamente es un proceso muy sencillo que no reviste dificultad
alguna. Antes de nada, hay que instalar las dependencias de la
librería, que son unas cuantas. Suponiendo que estás en un sistema
basado en Debian:


\begin{lstlisting}[style=consola]
sudo apt-get install g++ libgl1-mesa-dev libpango1.0-dev libboost1.40-dev libsdl-mixer1.2-dev libsdl-ttf2.0-dev
\end{lstlisting}

Una vez hecho, crea una carpeta para tu proyecto, por ejemplo
\texttt{miJuego}, descarga el código fuente de Gosu desde la página de
descargas (\url{http://code.google.com/p/gosu/downloads/list}) y
descomprímelo. Debería aparecer una carpeta \texttt{gosu} dentro de la
carpeta de tu proyecto.

Entra en \texttt{gosu} y luego en el subdirectorio \texttt{linux}, y
teclea:
\begin{lstlisting}[style=consola]
./configure
make
\end{lstlisting}

Ya está compilada y lista para usarse. Gosu suele adjuntarse con cada
proyecto, en lugar de instalarla a nivel de sistema, y se enlaza
estáticamente. Aunque de eso hablaremos más adelante.

\subsection{Conociendo boost}
A lo largo del tutorial, y en todo el código de la propia librería, se
hace uso de una parte de las librerías \textbf{Boost}. Para los que no
lo conozcan, Boost es un conjunto de librerías open source que amplían
las posibilidades del lenguaje C++. Después de la STL, se trata del
conjunto de librerías \textbf{más importante} que existe para este
lenguaje; tanto es así que la próxima versión de C++ (C++0x) incluirá
por defecto partes de Boost de forma estándar.

Las partes de Boost que se utilizarán son los \textbf{punteros
  inteligentes} (smart pointers). Estos punteros se diferencian
principalmente de los punteros tradicionales en que simplifican la
gestión de la memoria, mediante tareas como la \textbf{liberación
  automática} de la misma al finalizar su uso. En nuestro caso
usaremos concretamente dos tipos:
\begin{itemize}
\item \textbf{Scoped pointers:} Un scoped pointer
  (\texttt{boost::scoped\_ptr}) es un puntero que no puede copiarse, es
  decir, el objeto al que apunta no puede ser referenciado por ningún
  otro puntero, asegurándonos de que el único punto de acceso al mismo
  sea nuestro puntero original. Un scoped pointer pertenece a un
  ámbito (scope), y es liberado cuando el ámbito termina. Por ejemplo,
  si es un miembro de una clase, el puntero será liberado cuando se
  llame al destructor de la misma.
\item \textbf{Shared pointers:} Un shared pointer
  (\texttt{boost::shared\_ptr}) es parecido a un scoped pointer, se
  diferencia de él en que puede ser copiado, siendo éste su punto
  fuerte. El shared pointer llevará la cuenta de cuántos punteros
  están haciendo referencia al objeto creado, liberándose
  automáticamente cuando ya no quede ningún puntero. 

  Esto resulta muy útil a la hora de compartir un recurso entre varios
  objetos o clases, ya que de esta forma podemos olvidarnos de liberar
  el recurso cuand ya ningún objeto esté usándolo.
\end{itemize}

Cuando aparezcan en el tutorial, explicaremos la sintaxis de estos
punteros, aunque realmente no se diferencian en nada de los punteros
tradicionales, ya que también hacen uso del operador flecha.

\section{Empezando por el principio}

Bien, parece que quieres hacer un juego. Lo primero es hacer que
aparezca una ventana, porque no pretenderás que los muñequitos vayan
por la pantalla sin orden ni concierto.

El punto de partida para todas las aplicaciones Gosu es la clase
\texttt{Gosu::Window}. Se trata de una clase abstracta de la que
debemos heredar para empezar a hacer nuestro juego. Mucha palabrería
pero en realidad, nada del otro mundo. Abre un nuevo fichero
\texttt{main.cpp} y guárdalo en la carpeta principal de tu proyecto.

\begin{lstlisting}[style=C]
#include <iostream>
#include "Gosu/Gosu.hpp"

using namespace std;

class Juego : public Gosu::Window{

public:

    Juego() : Gosu::Window(640, 480, false){
	cout << "Constructor" << endl;
    }

    void update(){
	// Aquí va la lógica del juego
    }

    void draw(){
	// Dibujado
    }

    void buttonDown(Gosu::Button boton){
	if(boton == Gosu::kbEscape){
	    close();
	}
    }
};

int main(int argc, char *argv[])
{
    Juego J;
    J.show();

    return 0;
}
\end{lstlisting}



\pagebreak

\end{document}
